<!DOCTYPE html>
<!-- 
    Version déployée sur GitHub Pages
    URL de déploiement: https://juliuss34.github.io/nanobot-experience/
    Adaptée pour un fonctionnement optimal dans cet environnement
    Date d'adaptation: 21 mai 2025
-->

<!--
Version 17 - Mise à jour majeure avec améliorations de stabilité et interface:
- Intégration d'un mécanisme de sécurité anti-blocage empêchant l'écran de chargement infini
- Gestionnaire d'erreurs global pour garantir une expérience utilisateur fluide
- Optimisation du code JavaScript pour de meilleures performances
- Améliorations visuelles de l'interface utilisateur (animations et feedback)
- Transitions plus fluides entre les écrans
- Réactivité améliorée des boutons et éléments interactifs
- Sécurisation du processus de chargement/sauvegarde
- Réduction des doublons de code et meilleure organisation
- Optimisation de l'utilisation des ressources (mémoire et CPU)

Version 17 - Ajout d'un menu complet et notes de version:
- Création d'un écran d'accueil avec menu principal
- Option pour continuer une partie avec info de dernière sauvegarde
- Menu de paramètres complet pour audio et effets visuels
- Interface utilisateur améliorée avec transitions fluides
- Musique de fond avec options de contrôle
- Notes de version/patch notes accessibles depuis le menu
- Système de sauvegarde amélioré avec informations détaillées
-->

    <style>
/* Styles pour le système de menu et notes de version */
.menu-system {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    background: linear-gradient(135deg, rgba(10, 20, 30, 0.95), rgba(5, 15, 25, 0.98));
    transition: opacity 0.4s ease, transform 0.4s ease;
    color: white;
    padding: 20px;
    overflow: hidden;
}

.menu-system.hidden {
    opacity: 0;
    pointer-events: none;
    transform: translateY(-20px);
}

/* Logo du jeu */
.game-logo {
    margin-bottom: 40px;
    text-align: center;
    animation: pulse 3s infinite alternate;
}

.game-logo h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: 3.2rem;
    margin: 0;
    background: linear-gradient(45deg, var(--primary-color), var(--accent-color));
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    filter: drop-shadow(0 0 10px var(--primary-glow));
    letter-spacing: 2px;
}

.game-logo p {
    font-size: 1.2rem;
    opacity: 0.8;
    margin-top: 10px;
    font-style: italic;
}

/* Animation de pulsation */
@keyframes pulse {
    0% {
        text-shadow: 0 0 15px rgba(0, 119, 204, 0.5);
    }
    100% {
        text-shadow: 0 0 30px rgba(0, 119, 204, 0.8);
    }
}

/* Boutons du menu */
.menu-buttons {
    display: flex;
    flex-direction: column;
    gap: 15px;
    width: 300px;
    max-width: 100%;
}

.menu-button {
    background: rgba(0, 0, 0, 0.4);
    color: white;
    border: 1px solid rgba(0, 119, 204, 0.5);
    border-radius: 8px;
    padding: 15px 20px;
    font-family: 'Orbitron', sans-serif;
    font-size: 1.1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
}

.menu-button:hover {
    background: rgba(0, 119, 204, 0.2);
    border-color: var(--primary-color);
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.menu-button:active {
    transform: translateY(0);
}

.menu-button i {
    margin-right: 10px;
}

.menu-button.disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.save-info {
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.7);
    margin-top: 5px;
    text-align: center;
}

/* Particules d'arrière-plan */
.menu-particles {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    z-index: -1;
}

.particle {
    position: absolute;
    width: 2px;
    height: 2px;
    background-color: rgba(0, 119, 204, 0.6);
    border-radius: 50%;
    animation: float 15s infinite linear;
}

@keyframes float {
    0% {
        transform: translateY(100vh) translateX(0);
        opacity: 0;
    }
    10% {
        opacity: 1;
    }
    90% {
        opacity: 1;
    }
    100% {
        transform: translateY(-100px) translateX(100px);
        opacity: 0;
    }
}

/* Styles pour les écrans de menu */
.menu-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, rgba(10, 20, 30, 0.95), rgba(5, 15, 25, 0.98));
    z-index: 1001;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 40px 20px;
    color: white;
    transition: opacity 0.4s ease, transform 0.4s ease;
    overflow-y: auto;
}

.menu-screen.hidden {
    opacity: 0;
    pointer-events: none;
    transform: translateY(20px);
}

.screen-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    max-width: 700px;
    margin-bottom: 30px;
}

.screen-header h2 {
    font-family: 'Orbitron', sans-serif;
    margin: 0;
    color: var(--primary-color);
}

.back-button {
    background: none;
    border: none;
    color: var(--primary-color);
    font-size: 1.5rem;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
}

.back-button:hover {
    color: var(--accent-color);
    transform: translateX(-3px);
}

.back-button span {
    font-size: 0.9rem;
    margin-left: 5px;
}

/* Styles pour le menu des paramètres */
.settings-container {
    width: 100%;
    max-width: 700px;
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.settings-section {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    padding: 20px;
    border: 1px solid rgba(0, 119, 204, 0.2);
}

.settings-section h3 {
    margin-top: 0;
    margin-bottom: 15px;
    color: var(--accent-color);
    font-family: 'Orbitron', sans-serif;
    font-size: 1.2rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    padding-bottom: 8px;
}

.setting-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 15px;
    padding: 5px 0;
}

.setting-label {
    display: flex;
    align-items: center;
    font-weight: 500;
}

.setting-label i {
    margin-right: 10px;
    color: var(--primary-color);
    width: 20px;
    text-align: center;
}

.setting-control {
    display: flex;
    align-items: center;
}

/* Styles pour les toggles */
.toggle-switch {
    position: relative;
    display: inline-block;
    width: 44px;
    height: 24px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.4);
    transition: 0.3s;
    border-radius: 24px;
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.toggle-slider:before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 2px;
    background-color: white;
    transition: 0.3s;
    border-radius: 50%;
}

input:checked + .toggle-slider {
    background-color: var(--primary-color);
}

input:checked + .toggle-slider:before {
    transform: translateX(20px);
}

/* Styles pour les contrôles audio */
.audio-controls {
    display: flex;
    align-items: center;
    gap: 10px;
}

.volume-control {
    width: 120px;
}

.volume-display {
    width: 30px;
    text-align: right;
    font-size: 0.9rem;
    opacity: 0.8;
}

/* Styles pour les notes de version */
.version-notes {
    width: 100%;
    max-width: 700px;
    height: 100%;
    overflow-y: auto;
    padding-right: 10px;
}

.version-item {
    margin-bottom: 30px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    padding: 20px;
    border-left: 3px solid var(--primary-color);
}

.version-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.version-number {
    font-family: 'Orbitron', sans-serif;
    font-size: 1.3rem;
    color: var(--primary-color);
    margin: 0;
}

.version-date {
    font-size: 0.9rem;
    opacity: 0.7;
}

.version-features {
    list-style-type: none;
    padding: 0;
    margin: 0;
}

.version-feature {
    margin-bottom: 8px;
    padding-left: 20px;
    position: relative;
}

.version-feature:before {
    content: '•';
    position: absolute;
    left: 0;
    color: var(--accent-color);
}

/* Animation de chargement */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(5, 15, 25, 0.9);
    z-index: 2000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: opacity 0.3s ease;
}

.loading-overlay.hidden {
    opacity: 0;
    pointer-events: none;
}

/* Système audio */
#audio-system {
    display: none;
}

.audio-visualizer {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 30px;
    display: flex;
    justify-content: center;
    align-items: flex-end;
    z-index: 10;
    pointer-events: none;
    opacity: 0.5;
}

.visualizer-bars {
    display: flex;
    align-items: flex-end;
    gap: 3px;
}

.bar {
    width: 4px;
    height: 2px;
    background: var(--primary-color);
    border-radius: 1px;
    transition: height 0.1s ease;
}

/* Support mobile amélioré */
@media screen and (max-width: 768px) {
    .game-logo h1 {
        font-size: 2.5rem;
    }
    
    .menu-buttons {
        width: 280px;
    }
    
    .screen-header {
        margin-bottom: 20px;
    }
    
    .setting-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
    }
    
    .setting-control {
        width: 100%;
        justify-content: flex-end;
    }
    
    .version-header {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .version-date {
        margin-top: 5px;
    }
}
    
/* Améliorations visuelles V17 */
.game-button {
    transition: transform 0.1s ease, background-color 0.2s ease, box-shadow 0.2s ease;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.game-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
}

.game-button:active {
    transform: translateY(1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Animation de pulsation pour les éléments importants */
@keyframes pulse-v17 {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

.pulse-animation {
    animation: pulse-v17 1.5s infinite ease-in-out;
}

/* Meilleure transition pour les écrans */
.menu-system, .game-container {
    transition: opacity 0.3s ease, transform 0.3s ease;
}

.menu-system.hidden, .game-container.hidden {
    opacity: 0;
    transform: translateY(10px);
}

/* Indicateur de chargement amélioré */
.spinner {
    border-width: 4px;
    box-shadow: 0 0 15px var(--accent-color);
}

/* Feedback visuel pour les actions */
.resource-feedback {
    position: absolute;
    color: var(--accent-color);
    font-weight: bold;
    pointer-events: none;
    animation: float-up 1s ease-out forwards;
    text-shadow: 0 0 5px var(--bg-color);
}

@keyframes float-up {
    0% { opacity: 1; transform: translateY(0); }
    100% { opacity: 0; transform: translateY(-20px); }
}

/* Nouvelle animation pour les particules */
.menu-particles canvas {
    animation: glow 4s infinite alternate;
}

@keyframes glow {
    0% { filter: brightness(0.9) saturate(0.9); }
    100% { filter: brightness(1.1) saturate(1.1); }
}
</style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <link rel="icon" href="favicon.jpg" type="image/jpeg">
    <link rel="shortcut icon" href="favicon.jpg" type="image/jpeg">
</head>
<body>
    <!-- Système audio -->
    <div id="audio-system">
        <audio id="background-music" loop preload="auto">
            <source src="https://assets.codepen.io/217233/synthtune.mp3" type="audio/mpeg">
            <source src="https://ia800504.us.archive.org/33/items/TronLegacy2010/17.SolarSailor.mp3" type="audio/mpeg">
            Votre navigateur ne supporte pas l'élément audio.
        </audio>
    </div>
    
    <!-- Visualiseur audio -->
    <div id="audio-visualizer" class="audio-visualizer">
        <div class="visualizer-bars">
            <div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div>
            <div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div>
            <div class="bar"></div><div class="bar"></div><div class="bar"></div><div class="bar"></div>
        </div>
    </div>

    <!-- Écran de chargement -->
    <div id="loading-overlay" class="loading-overlay">
        <div class="spinner"></div>
        <p class="loading-text">Chargement de Nano Bot Experience...</p>
    </div>
    
    <!-- Menu principal -->
    <div id="main-menu" class="menu-system">
        <div class="menu-particles" id="menu-particles"></div>
        
        <div class="game-logo">
            <h1>Nano Bot Experience</h1>
            <p>Conquérir l'univers à l'échelle nanométrique</p>
        </div>
        
        <div class="menu-buttons">
            <button id="continue-game" class="menu-button">
                <i class="fas fa-play"></i> Continuer
                <div id="save-details" class="save-info"></div>
            </button>
            
            <button id="new-game" class="menu-button">
                <i class="fas fa-plus"></i> Nouvelle partie
            </button>
            
            <button id="open-settings" class="menu-button">
                <i class="fas fa-cog"></i> Paramètres
            </button>
            
            <button id="show-version-notes" class="menu-button">
                <i class="fas fa-clipboard-list"></i> Notes de version
            </button>
        </div>
    </div>
    
    <!-- Menu des paramètres -->
    <div id="settings-menu" class="menu-screen hidden">
        <div class="screen-header">
            <h2>Paramètres</h2>
            <button id="settings-back" class="back-button">
                <i class="fas fa-arrow-left"></i>
                <span>Retour</span>
            </button>
        </div>
        
        <div class="settings-container">
            <div class="settings-section">
                <h3>Audio</h3>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <i class="fas fa-music"></i>
                        Musique de fond
                    </div>
                    <div class="setting-control">
                        <label class="toggle-switch">
                            <input type="checkbox" id="music-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <i class="fas fa-volume-up"></i>
                        Volume
                    </div>
                    <div class="setting-control audio-controls">
                        <input type="range" id="volume-slider" min="0" max="100" value="70">
                        <div id="volume-value" class="volume-display">70%</div>
                    </div>
                </div>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <i class="fas fa-wave-square"></i>
                        Visualiseur audio
                    </div>
                    <div class="setting-control">
                        <label class="toggle-switch">
                            <input type="checkbox" id="visualizer-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="settings-section">
                <h3>Interface</h3>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <i class="fas fa-moon"></i>
                        Thème sombre
                    </div>
                    <div class="setting-control">
                        <label class="toggle-switch">
                            <input type="checkbox" id="dark-theme-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <i class="fas fa-magic"></i>
                        Effets de particules
                    </div>
                    <div class="setting-control">
                        <label class="toggle-switch">
                            <input type="checkbox" id="particles-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <i class="fas fa-bell"></i>
                        Notifications
                    </div>
                    <div class="setting-control">
                        <label class="toggle-switch">
                            <input type="checkbox" id="notifications-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="settings-section">
                <h3>Sauvegarde</h3>
                
                <div class="setting-item">
                    <div class="setting-label">
                        <i class="fas fa-save"></i>
                        Sauvegarde automatique
                    </div>
                    <div class="setting-control">
                        <label class="toggle-switch">
                            <input type="checkbox" id="autosave-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                
                <div class="setting-item">
                    <button id="reset-game-button" class="menu-button" style="width: 100%; justify-content: center; background: rgba(204, 0, 0, 0.2); border-color: rgba(204, 0, 0, 0.5);">
                        <i class="fas fa-trash"></i> Réinitialiser les données
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Notes de version -->
    <div id="version-notes-menu" class="menu-screen hidden">
        <div class="screen-header">
            <h2>Notes de Version</h2>
            <button id="version-notes-back" class="back-button">
                <i class="fas fa-arrow-left"></i>
                <span>Retour</span>
            </button>
        </div>
        
        <div class="version-notes">
            <div class="version-item">
                <div class="version-header">
                    <h3 class="version-number">Version 17</h3>
                    <div class="version-date">21 Mai 2025</div>
                </div>
                <ul class="version-features">
                    <li class="version-feature">Création d'un écran d'accueil avec menu principal</li>
                    <li class="version-feature">Option pour continuer une partie avec info de dernière sauvegarde</li>
                    <li class="version-feature">Menu de paramètres complet pour audio et effets visuels</li>
                    <li class="version-feature">Interface utilisateur améliorée avec transitions fluides</li>
                    <li class="version-feature">Musique de fond avec options de contrôle</li>
                    <li class="version-feature">Notes de version/patch notes accessibles depuis le menu</li>
                    <li class="version-feature">Système de sauvegarde amélioré avec informations détaillées</li>
                </ul>
            </div>
            
            <div class="version-item">
                <div class="version-header">
                    <h3 class="version-number">Version 15</h3>
                    <div class="version-date">20 Mai 2025</div>
                </div>
                <ul class="version-features">
                    <li class="version-feature">Intégration d'une musique de fond ambiance sci-fi/synthwave</li>
                    <li class="version-feature">Contrôle de volume et bouton mute/unmute dans le footer</li>
                    <li class="version-feature">Sauvegarde des préférences audio avec le jeu</li>
                    <li class="version-feature">Animation visuelle réactive au son</li>
                </ul>
            </div>
            
            <div class="version-item">
                <div class="version-header">
                    <h3 class="version-number">Version 14</h3>
                    <div class="version-date">18 Mai 2025</div>
                </div>
                <ul class="version-features">
                    <li class="version-feature">Correction du bug des boutons qui ne s'actualisent pas lors de clics rapides</li>
                    <li class="version-feature">Amélioration de la réactivité de l'interface</li>
                    <li class="version-feature">Ajout d'effets visuels pour les boutons d'achat</li>
                    <li class="version-feature">Système anti-spam pour les clics rapides</li>
                </ul>
            </div>
            
            <div class="version-item">
                <div class="version-header">
                    <h3 class="version-number">Version 13</h3>
                    <div class="version-date">15 Mai 2025</div>
                </div>
                <ul class="version-features">
                    <li class="version-feature">Correction du bug d'affichage du nombre de Nano-Assembleurs</li>
                    <li class="version-feature">Correction du bug du taux de production non mis à jour correctement</li>
                    <li class="version-feature">Ajout de styles CSS pour améliorer la visibilité des compteurs</li>
                </ul>
            </div>
            
            <div class="version-item">
                <div class="version-header">
                    <h3 class="version-number">Version 12</h3>
                    <div class="version-date">10 Mai 2025</div>
                </div>
                <ul class="version-features">
                    <li class="version-feature">Ajout de nouveaux thèmes de couleurs: Vert Cybernétique, Orange Solaire, Violet Quantique</li>
                    <li class="version-feature">Implémentation d'un sélecteur de thèmes d'accent dans le footer</li>
                    <li class="version-feature">Ajout de la propriété accentColorTheme dans game.settings</li>
                    <li class="version-feature">Persistance du choix de couleur à travers les sauvegardes</li>
                    <li class="version-feature">Compatible avec le thème clair/sombre existant</li>
                </ul>
            </div>
        </div>
    </div>
    
    <!-- Notification de sauvegarde -->
    <div id="save-notification" class="save-notification">
        <i class="fas fa-save"></i> Partie sauvegardée
    </div>

    <!-- Conteneur principal de jeu -->
    <div class="game-container" style="display: none;">
        <header>
            <h1>Nano Bot Experience</h1>
            <div class="subtitle">Conquérir l'univers à l'échelle nanométrique</div>
            
            <div class="stats">
                <div class="stat primary">
                    <i class="fas fa-microchip"></i>
                    <span id="nanobots">0</span> nanobots
                </div>
                <div class="stat">
                    <i class="fas fa-bolt"></i>
                    <span id="per-second">0.0</span> par seconde
                </div>
                <div class="stat">
                    <i class="fas fa-globe"></i>
                    Expansion: <span id="expansion-level">Terre</span>
                </div>
            </div>
        </header>

        <main>
            <div class="clicker-section">
                <button id="clicker">Répliquer</button>
                <div class="click-value">+<span id="click-value">1</span> nanobots par clic</div>
            </div>

            <div class="progress-container">
                <div class="progress-bar">
                    <div id="expansion-progress" class="progress-fill"></div>
                </div>
                <div class="progress-text">Progression vers la prochaine zone: <span id="expansion-percent">0</span>%</div>
            </div>

            <div class="sections-container">
                <section class="producers">
                    <h2><i class="fas fa-industry"></i> Fabrication</h2>
                    <div id="producers-container"></div>
                </section>

                <section class="upgrades">
                    <h2><i class="fas fa-flask"></i> Recherche</h2>
                    <div id="upgrades-container"></div>
                </section>
            </div>

            <section class="expansion-milestones">
                <h2><i class="fas fa-rocket"></i> Expansion</h2>
                <div id="milestones-container" class="milestones-grid"></div>
            </section>

            <section class="prestige-section" id="prestige-section">
                <h2><i class="fas fa-dna"></i> Évolution Nanobotique</h2>
                <p>Niveau d'évolution actuel: <span id="prestige-points">0</span></p>
                <p>Multiplicateur actuel: <span id="prestige-multiplier">x1.0</span></p>
                <p>Évolution potentielle: <span id="prestige-to-gain">0</span> niveau(x)</p>
                <button id="prestige-button" disabled>Évoluer vers la prochaine génération</button>
            </section>
            
            <section class="achievements-section">
                <h2><i class="fas fa-trophy"></i> Succès <span class="achievements-bonus">+<span id="achievements-bonus">0</span>% de production</span></h2>
                <div id="achievements-container" class="achievements-grid"></div>
            </section>
        </main>

        <footer>
            <div class="footer-buttons">
                <button id="save-button"><i class="fas fa-save"></i> Sauvegarder</button>
                <button id="reset-button"><i class="fas fa-trash"></i> Réinitialiser</button>
                <button id="theme-toggle"><i class="fas fa-moon"></i> <span>Thème</span></button>
            </div>
            <div class="info">
                Dernière sauvegarde: <span id="last-save">Jamais</span>
            </div>
            <div id="color-picker-container">
                <button class="color-option" data-theme="default-blue" title="Bleu Défaut"></button>
                <button class="color-option" data-theme="cyber-green" title="Vert Cybernétique"></button>
                <button class="color-option" data-theme="solar-orange" title="Orange Solaire"></button>
                <button class="color-option" data-theme="quantum-purple" title="Violet Quantique"></button>
            </div>
        </footer>
    </div>

    <!-- Ajout du script pour les particules en arrière-plan -->
    <script>
/* 
 * OPTIMISATION V17 FINALE:
 * - Suppression des gestionnaires d'erreurs en double
 * - Élimination des écouteurs d'événements redondants
 * - Uniformisation des références de version
 * - Optimisation des performances
 * - Date d'optimisation: 21 mai 2025
 */

// ===== MÉCANISME DE SÉCURITÉ (V17) =====
// Ce code garantit que l'écran de chargement ne reste jamais bloqué
// Mécanisme de sécurité pour éviter le chargement infini
(function() {
    console.log("Initialisation du mécanisme de sécurité anti-blocage");
    
    // Forcer la fin du chargement après 3 secondes
    window.setTimeout(function() {
        const loadingOverlay = document.getElementById('loading-overlay');
        const mainMenu = document.getElementById('main-menu');
        
        if (loadingOverlay && !loadingOverlay.classList.contains('hidden')) {
            console.log("SÉCURITÉ ACTIVÉE: Forçage de la fin du chargement");
            loadingOverlay.classList.add('hidden');
            
            if (mainMenu) {
                mainMenu.classList.remove('hidden');
                console.log("Menu principal affiché par le mécanisme de sécurité");
            }
        }
    }, 3000);
    
    // Gestionnaire global d'erreurs
    
})();

// Fonction pour créer un effet de feedback visuel (V17)
function createVisualFeedback(element, text, type = 'default') {
    const feedback = document.createElement('div');
    feedback.textContent = text;
    feedback.classList.add('resource-feedback');
    
    // Différents types de feedback
    if (type === 'success') {
        feedback.style.color = '#4CAF50';
    } else if (type === 'warning') {
        feedback.style.color = '#FF9800';
    } else if (type === 'error') {
        feedback.style.color = '#F44336';
    }
    
    // Positionner le feedback par rapport à l'élément
    const rect = element.getBoundingClientRect();
    feedback.style.left = rect.left + rect.width / 2 + 'px';
    feedback.style.top = rect.top + 'px';
    
    document.body.appendChild(feedback);
    
    // Supprimer après l'animation
    setTimeout(() => {
        if (feedback && feedback.parentNode) {
            feedback.parentNode.removeChild(feedback);
        }
    }, 1000);
}




// Gestionnaire d'erreurs global


    // Fonction globale pour les particules - sera appelée par init()
        // Création aléatoire de particules en arrière-plan
        function createBackgroundParticles() {
            const container = document.querySelector('.game-container');
            const particleCount = 15;
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'floating-nanobot';
                
                // Positions aléatoires
                const x = Math.random() * 100;
                const y = Math.random() * 100;
                const delay = Math.random() * 10;
                const duration = 5 + Math.random() * 10;
                const size = 2 + Math.random() * 3;
                
                particle.style.left = `${x}%`;
                particle.style.top = `${y}%`;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.opacity = '0.3';
                particle.style.animationDelay = `${delay}s`;
                particle.style.animationDuration = `${duration}s`;
                
                container.appendChild(particle);
                
                // Supprimer et recréer la particule après son animation
                setTimeout(() => {
                    particle.remove();
                // Code de création directe de nouvelle particule au lieu d'appeler createParticle
                const newParticle = document.createElement('div');
                newParticle.className = 'floating-nanobot';
                
                // Positions aléatoires pour la nouvelle particule
                const newX = Math.random() * 100;
                const newY = Math.random() * 100;
                const newDelay = Math.random() * 10;
                const newDuration = 5 + Math.random() * 10;
                const newSize = 2 + Math.random() * 3;
                
                newParticle.style.left = `${newX}%`;
                newParticle.style.top = `${newY}%`;
                newParticle.style.width = `${newSize}px`;
                newParticle.style.height = `${newSize}px`;
                newParticle.style.opacity = '0.3';
                newParticle.style.animationDuration = `${newDuration}s`;
                
                container.appendChild(newParticle);
                
                // Auto-suppression
                setTimeout(() => {
                    newParticle.remove();
                }, newDuration * 1000);
                }, duration * 1000 + delay * 1000);
            }
        }
        
        function createParticle() {
            const container = document.querySelector('.game-container');
            const particle = document.createElement('div');
            particle.className = 'floating-nanobot';
            
            // Positions aléatoires
            const x = Math.random() * 100;
            const y = 80 + Math.random() * 20; // Partir du bas
            const duration = 5 + Math.random() * 10;
            const size = 2 + Math.random() * 3;
            
            particle.style.left = `${x}%`;
            particle.style.top = `${y}%`;
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.opacity = '0.3';
            particle.style.animationDuration = `${duration}s`;
            
            container.appendChild(particle);
            
            // Supprimer et recréer la particule après son animation
            setTimeout(() => {
                particle.remove();
                // Correct function call to createBackgroundParticles instead of undefined createParticle
                const newParticle = document.createElement('div');
                newParticle.className = 'floating-nanobot';
                
                // Positions aléatoires pour la nouvelle particule
                const newX = Math.random() * 100;
                const newY = Math.random() * 100;
                const newDelay = Math.random() * 10;
                const newDuration = 5 + Math.random() * 10;
                const newSize = 2 + Math.random() * 3;
                
                newParticle.style.left = `${newX}%`;
                newParticle.style.top = `${newY}%`;
                newParticle.style.width = `${newSize}px`;
                newParticle.style.height = `${newSize}px`;
                newParticle.style.opacity = '0.3';
                newParticle.style.animationDuration = `${newDuration}s`;
                
                container.appendChild(newParticle);
                
                // Auto-suppression
                setTimeout(() => {
                    newParticle.remove();
                }, newDuration * 1000);
            }, duration * 1000);
        }
        
        // Initialiser les particules plus tard via init()
    </script>
    <script>

// Gestionnaire d'erreurs global


// État du jeu
// ATTENTION: Cette variable est globale et ne doit pas être redéclarée ailleurs !
// Si vous la redéclarez avec "let game" dans une autre portée, cela masquera cette variable globale.
let game = {
    // Ressources
    nanobots: 0,
    totalNanobots: 0,
    clickValue: 1,
    
    // Expansion et zones
    expansion: {
        currentLevel: 0,
        progressToNext: 0,
        levelNames: [
            "Terre", "Système Solaire", "Voie Lactée", 
            "Groupe Local", "Super-amas Local", "Univers Observable",
            "Multivers", "Dimensions Parallèles", "Réalité Quantique"
        ],
        milestones: [
            { name: "Terre", desc: "Point de départ", icon: "globe", unlocked: true, nanobotReq: 0 },
            { name: "Lune", desc: "+10% production", icon: "moon", unlocked: false, nanobotReq: 1e3, effect: () => { applyProductionMultiplier(1.1); } },
            { name: "Mars", desc: "+15% production", icon: "rocket", unlocked: false, nanobotReq: 1e4, effect: () => { applyProductionMultiplier(1.15); } },
            { name: "Système Solaire", desc: "+25% production", icon: "sun", unlocked: false, nanobotReq: 1e6, effect: () => { applyProductionMultiplier(1.25); } },
            { name: "Étoiles Proches", desc: "Débloque nouvel assembleur", icon: "star", unlocked: false, nanobotReq: 1e8, effect: () => { unlockProducer(3); } },
            { name: "Voie Lactée", desc: "+50% production", icon: "galaxy", unlocked: false, nanobotReq: 1e10, effect: () => { applyProductionMultiplier(1.5); } },
            { name: "Galaxies Voisines", desc: "Double valeur des clics", icon: "atom", unlocked: false, nanobotReq: 1e13, effect: () => { game.clickValue *= 2; } },
            { name: "Groupe Local", desc: "+100% production", icon: "meteor", unlocked: false, nanobotReq: 1e16, effect: () => { applyProductionMultiplier(2); } },
            { name: "Super-amas Local", desc: "Débloque évolution quantique", icon: "project-diagram", unlocked: false, nanobotReq: 1e20, effect: () => { unlockProducer(5); } },
            { name: "Univers Observable", desc: "Triple toute production", icon: "microscope", unlocked: false, nanobotReq: 1e25, effect: () => { applyProductionMultiplier(3); } },
            { name: "Multivers", desc: "Débloque réplicateurs ultimes", icon: "cube", unlocked: false, nanobotReq: 1e30, effect: () => { unlockProducer(6); } },
            { name: "Dimensions Parallèles", desc: "x10 à la valeur des clics", icon: "cubes", unlocked: false, nanobotReq: 1e35, effect: () => { game.clickValue *= 10; } },
            { name: "Réalité Quantique", desc: "Maîtrise totale", icon: "infinity", unlocked: false, nanobotReq: 1e40, effect: () => { applyProductionMultiplier(10); } }
        ]
    },
    
    // Producteurs
    producers: [
        { id: 'producer1', name: 'Nano-Assembleur', count: 0, baseCost: 10, costMultiplier: 1.1, production: 0.1, unlocked: true, 
          desc: "Assemble des nanobots individuellement", icon: "microchip" },
        { id: 'producer2', name: 'Réplicateur Moléculaire', count: 0, baseCost: 100, costMultiplier: 1.12, production: 1, unlocked: false, 
          desc: "Réplique les nanobots au niveau moléculaire", icon: "code-branch" },
        { id: 'producer3', name: 'Usine Quantique', count: 0, baseCost: 1500, costMultiplier: 1.15, production: 10, unlocked: false, 
          desc: "Utilise les fluctuations quantiques pour générer des nanobots", icon: "atom" },
        { id: 'producer4', name: 'Matrice Stellaire', count: 0, baseCost: 20000, costMultiplier: 1.17, production: 100, unlocked: false, 
          desc: "Convertit l'énergie stellaire en nanobots", icon: "sun" },
        { id: 'producer5', name: 'Condensateur Galactique', count: 0, baseCost: 500000, costMultiplier: 1.18, production: 1000, unlocked: false, 
          desc: "Condense la matière interstellaire en nanobots", icon: "galaxy" },
        { id: 'producer6', name: 'Transmutateur Quantique', count: 0, baseCost: 10000000, costMultiplier: 1.2, production: 10000, unlocked: false, 
          desc: "Transmute l'énergie du vide en nanobots", icon: "project-diagram" },
        { id: 'producer7', name: 'Générateur Dimensionnel', count: 0, baseCost: 500000000, costMultiplier: 1.22, production: 100000, unlocked: false, 
          desc: "Extrait des nanobots d'autres dimensions", icon: "cube" }
    ],
    
    // Améliorations
    upgrades: [
        { id: 'upgrade1', name: 'Protocole d\'auto-réplication', description: 'Double la valeur de vos clics', cost: 50, purchased: false, 
          effect: () => { game.clickValue *= 2; }, icon: "hand-pointer" },
        { id: 'upgrade2', name: 'Nano-processeurs avancés', description: 'Double la production des Nano-Assembleurs', cost: 200, purchased: false, 
          effect: () => { 
              
              const producerIndex = game.producers.findIndex(p => p.id === 'producer1');
              if (producerIndex !== -1) {
                  multiplyProducerProduction(producerIndex, 2);
              } else {
                  console.error("Producteur 'Nano-Assembleur' non trouvé pour l'amélioration");
              }
          }, 
          requirement: () => {
              // Recherche du producteur par ID pour plus de robustesse
              const producer = game.producers.find(p => p.id === 'producer1');
              return producer && producer.count >= 10;
          }, 
          icon: "microchip" 
        },
        { id: 'upgrade3', name: 'Algorithmes adaptatifs', description: 'Triple la production des Réplicateurs Moléculaires', cost: 1000, purchased: false, 
          effect: () => {
              const producerIndex = game.producers.findIndex(p => p.id === 'producer2');
              if (producerIndex !== -1) {
                  multiplyProducerProduction(producerIndex, 3);
              } else {
                  console.error("Producteur 'Réplicateur Moléculaire' non trouvé pour l'amélioration");
              }
          },
          requirement: () => {
              const producer = game.producers.find(p => p.id === 'producer2');
              return producer && producer.count >= 10;
          },
          icon: "brain" 
        },
        { id: 'upgrade4', name: 'Manipulation atomique', description: 'Double la production de tous les producteurs', cost: 5000, purchased: false, 
          effect: () => { applyProductionMultiplier(2); }, 
          requirement: () => game.totalNanobots >= 2000, 
          icon: "atom" 
        },
        { id: 'upgrade5', name: 'Compression moléculaire', description: 'Tous les coûts -10%', cost: 20000, purchased: false, 
          effect: () => { applyCostReduction(0.9); }, 
          requirement: () => game.expansion && game.expansion.currentLevel >= 1, 
          icon: "compress" 
        },
        { id: 'upgrade6', name: 'Intelligence collective', description: 'Production +50% par zone débloquée', cost: 100000, purchased: false, 
          effect: () => { 
              if (typeof recalculateCollectiveIntelligence === 'function') {
                  recalculateCollectiveIntelligence();
              } else {
                  // Fallback si la fonction n'existe pas
                  applyProductionMultiplier(1.5);
              }
          }, 
          requirement: () => game.expansion && game.expansion.currentLevel >= 2, 
          icon: "network-wired" 
        },
        { id: 'upgrade7', name: 'Manipulation quantique', description: 'Quadruple la production des Usines Quantiques', cost: 500000, purchased: false, 
          effect: () => {
              const producerIndex = game.producers.findIndex(p => p.id === 'producer3');
              if (producerIndex !== -1) {
                  multiplyProducerProduction(producerIndex, 4);
              } else {
                  console.error("Producteur 'Usine Quantique' non trouvé pour l'amélioration");
              }
          },
          requirement: () => {
              const producer = game.producers.find(p => p.id === 'producer3');
              return producer && producer.count >= 15;
          },
          icon: "dice-d20" 
        },
        { id: 'upgrade8', name: 'Matière noire', description: 'Production x5 pendant 30 secondes', cost: 2000000, purchased: false, 
          effect: () => { 
              if (typeof applyTemporaryBoost === 'function') {
                  applyTemporaryBoost(5, 30);
              } else {
                  // Fallback si la fonction n'existe pas
                  applyProductionMultiplier(5);
              }
          }, 
          requirement: () => game.expansion && game.expansion.currentLevel >= 3, 
          icon: "star-half-alt" 
        },
        { id: 'upgrade9', name: 'Singularité technologique', description: 'Production x10 mais consomme 1% de nanobots/sec', cost: 50000000, purchased: false, 
          effect: () => { 
              if (typeof applySingularity === 'function') {
                  applySingularity();
              } else {
                  // Fallback si la fonction n'existe pas
                  applyProductionMultiplier(10);
              }
          }, 
          requirement: () => game.expansion && game.expansion.currentLevel >= 5, 
          icon: "bullseye" 
        }
    ],
    
    // Prestige (évolution nanobotique)
    prestige: {
        points: 0,
        multiplier: 1,
        toGain: 0,
        unlocked: false
    },
    
    // Boosts temporaires
    temporaryBoosts: [],
    
    // Statistiques
    stats: {
        clickCount: 0,
        playTime: 0,
        prestigeCount: 0
    },
    
    // Timing et sauvegarde
    lastUpdate: Date.now(),
    lastSave: null,
    
    // Paramètres et préférences
    settings: {
        showAutoSaveNotification: true,   // Afficher ou non les notifications de sauvegarde automatique
        theme: 'dark',                    // Thème actuel (dark ou light)
        accentColorTheme: 'default-blue', // Thème de couleur d'accent
        particleEffects: true,            // Afficher les effets de particules
        showTutorial: true,               // Afficher le tutoriel
        autoSave: true,                   // Sauvegarder automatiquement
        audio: {
            enabled: true,                // Musique activée
            volume: 0.7,                  // Volume de la musique (0-1)
            visualizer: true              // Afficher le visualiseur audio
        }
    },
    
    // Système de succès
    achievementBonus: 0,                  // Bonus de production (+1% par succès)
    achievements: [
        { 
            id: 'achievement1',
            name: 'Premier pas',
            description: 'Produire 100 nanobots au total',
            icon: 'baby',
            unlocked: false,
            condition: () => game.totalNanobots >= 100,
            rewardText: '+1% de production'
        },
        {
            id: 'achievement2',
            name: 'Expansion locale',
            description: 'Atteindre le niveau Lune',
            icon: 'moon',
            unlocked: false,
            condition: () => game.expansion.milestones.find(m => m.name === "Lune")?.unlocked,
            rewardText: '+1% de production'
        },
        {
            id: 'achievement3',
            name: 'Usine à nanobots',
            description: 'Posséder 10 Nano-Assembleurs',
            icon: 'industry',
            unlocked: false,
            condition: () => game.producers[0].count >= 10,
            rewardText: '+1% de production'
        },
        {
            id: 'achievement4',
            name: 'Cliqueur professionnel',
            description: 'Cliquer 100 fois',
            icon: 'hand-pointer',
            unlocked: false,
            condition: () => game.stats.clickCount >= 100,
            rewardText: '+1% de production'
        },
        {
            id: 'achievement5',
            name: 'Millionnaire',
            description: 'Produire 1 million de nanobots au total',
            icon: 'chart-line',
            unlocked: false,
            condition: () => game.totalNanobots >= 1e6,
            rewardText: '+1% de production'
        },
        {
            id: 'achievement6',
            name: 'Premier système',
            description: 'Atteindre le niveau Système Solaire',
            icon: 'sun',
            unlocked: false,
            condition: () => game.expansion.milestones.find(m => m.name === "Système Solaire")?.unlocked,
            rewardText: '+1% de production'
        },
        {
            id: 'achievement7',
            name: 'Collection complète',
            description: 'Posséder au moins 1 exemplaire de chaque producteur débloqué',
            icon: 'layer-group',
            unlocked: false,
            condition: () => {
                const unlockedProducers = game.producers.filter(p => p.unlocked);
                return unlockedProducers.every(p => p.count > 0);
            },
            rewardText: '+1% de production'
        },
        {
            id: 'achievement8',
            name: 'Renaissance',
            description: 'Effectuer un prestige',
            icon: 'sync-alt',
            unlocked: false,
            condition: () => game.stats.prestigeCount > 0,
            rewardText: '+1% de production'
        }
    ]
};

// Éléments DOM
const elements = {
    nanobots: document.getElementById('nanobots'),
    perSecond: document.getElementById('per-second'),
    clickValue: document.getElementById('click-value'),
    expansionLevel: document.getElementById('expansion-level'),
    expansionProgress: document.getElementById('expansion-progress'),
    expansionPercent: document.getElementById('expansion-percent'),
    clicker: document.getElementById('clicker'),
    producersContainer: document.getElementById('producers-container'),
    upgradesContainer: document.getElementById('upgrades-container'),
    milestonesContainer: document.getElementById('milestones-container'),
    prestigePoints: document.getElementById('prestige-points'),
    prestigeMultiplier: document.getElementById('prestige-multiplier'),
    prestigeToGain: document.getElementById('prestige-to-gain'),
    prestigeButton: document.getElementById('prestige-button'),
    saveButton: document.getElementById('save-button'),
    resetButton: document.getElementById('reset-button'),
    themeToggle: document.getElementById('theme-toggle'),
    lastSave: document.getElementById('last-save'),
    achievementsContainer: document.getElementById('achievements-container'),
    achievementsBonus: document.getElementById('achievements-bonus')
};

// Fonctions utilitaires
function formatNumber(num) {
    if (num < 1000) return num.toFixed(1).replace(/\.0$/, '');
    
    const units = ['', 'K', 'M', 'B', 'T', 'Qa', 'Qi', 'Sx', 'Sp', 'Oc', 'No', 'Dc', 'UDc', 'DDc', 'TDc', 'QaDc', 'QiDc'];
    const exponent = Math.floor(Math.log10(num) / 3);
    const unit = units[exponent] || `e${exponent*3}`;
    
    return (num / Math.pow(10, exponent * 3)).toFixed(2).replace(/\.00$/, '') + unit;
}

// Fonction pour arrêter la boucle de jeu proprement
function stopGameLoop() {
    if (game.gameLoopId) {
        cancelAnimationFrame(game.gameLoopId);
        game.gameLoopId = null;
    }
}

function formatTime(timestamp) {
    if (!timestamp) return 'Jamais';
    const date = new Date(timestamp);
    return date.toLocaleTimeString();
}

// Fonction pour calculer la production par seconde
function calculateProduction() {
    // Protection contre les NaN
    try {
        let production = 0;
        
        // Vérifier que game.producers existe et est un tableau
        if (Array.isArray(game.producers)) {
            game.producers.forEach(producer => {
                // Vérifier que les valeurs sont numériques
                const count = Number(producer.count) || 0;
                const prodValue = Number(producer.production) || 0;
                production += count * prodValue;
            });
        }
        
        // Appliquer multiplicateur de prestige avec vérification
        const prestigeMultiplier = Number(game.prestige?.multiplier) || 1;
        production *= prestigeMultiplier;
        
        // Appliquer boosts temporaires
        if (Array.isArray(game.temporaryBoosts)) {
            game.temporaryBoosts.forEach(boost => {
                const boostMultiplier = Number(boost.multiplier) || 1;
                production *= boostMultiplier;
            });
        }
        
        // Appliquer le bonus des succès (+1% par succès débloqué)
        const achievementBonus = Number(game.achievementBonus) || 0;
        if (achievementBonus > 0) {
            production *= (1 + (achievementBonus * 0.01));
        }
        
        // Protection finale contre NaN ou valeurs négatives
        if (isNaN(production) || production < 0) {
            console.error("Production invalide calculée:", production);
            return 0;
        }
        
        return production;
    } catch (error) {
        console.error("Erreur dans le calcul de production:", error);
        return 0;
    }
}

// Fonction pour calculer le coût d'un producteur
function getProducerCost(producer) {
    try {
        // Vérification que les valeurs sont numériques
        const baseCost = Number(producer.baseCost) || 10; 
        const costMultiplier = Number(producer.costMultiplier) || 1.1; // Valeur par défaut
        const count = Number(producer.count) || 0;
        
        // Calcul du coût avec une limitation pour éviter des valeurs extrêmes
        const cost = Math.floor(baseCost * Math.pow(costMultiplier, count));
        
        // Protection contre NaN, infini ou valeurs négatives
        if (isNaN(cost) || !isFinite(cost) || cost <= 0) {
            console.error("Coût de producteur invalide calculé:", cost);
            return baseCost; // Revenir à la base par défaut
        }
        
        return cost;
    } catch (error) {
        console.error("Erreur dans le calcul du coût du producteur:", error);
        return producer.baseCost || 10; // Valeur par défaut
    }
}

/**
 * Version robuste qui fusionne et nettoie un état de jeu chargé avec un état par défaut
 * @param {Object} loadedState - L'état chargé (potentiellement incomplet ou corrompu)
 * @param {Object} defaultState - L'état par défaut complet (résultat de getDefaultGameState())
 * @returns {Object} - Un nouvel état de jeu propre et complet
 */
function sanitizeGameState(loadedState, defaultState) {
    console.log("Sanitization de l'état du jeu...", "Type de loadedState:", typeof loadedState, "Type de defaultState:", typeof defaultState);
    
    // Vérification rigoureuse des arguments
    if (!defaultState || typeof defaultState !== 'object') {
        console.error("ERREUR CRITIQUE: defaultState est invalide dans sanitizeGameState!");
        // Situation catastrophique, nous devons au moins retourner un objet minimal
        return {
            nanobots: 0,
            totalNanobots: 0,
            clickValue: 1,
            lastUpdate: Date.now(),
            producers: [],
            upgrades: [],
            settings: { theme: 'dark', showAutoSaveNotification: true }
        };
    }
    
    // Si loadedState est null/undefined ou pas un objet, retourner une copie de defaultState
    if (!loadedState || typeof loadedState !== 'object') {
        console.warn("État chargé invalide, utilisation de l'état par défaut");
        return JSON.parse(JSON.stringify(defaultState));
    }
    
    // Créer un nouvel objet à partir de defaultState
    const sanitizedState = JSON.parse(JSON.stringify(defaultState));
    
    try {
        // 1. Copier les propriétés primitives simples avec vérification de type
        const numericProps = ['nanobots', 'totalNanobots', 'clickValue', 'achievementBonus'];
        numericProps.forEach(prop => {
            if (typeof loadedState[prop] === 'number' && !isNaN(loadedState[prop])) {
                // Pour clickValue, ne jamais descendre en dessous de 1
                if (prop === 'clickValue') {
                    sanitizedState[prop] = Math.max(1, loadedState[prop]);
                } else {
                    // Pour les autres propriétés numériques, ne jamais descendre en dessous de 0
                    sanitizedState[prop] = Math.max(0, loadedState[prop]);
                }
            } else {
                console.warn(`Propriété numérique invalide: ${prop}, utilisation de la valeur par défaut`);
            }
        });
        
        // Copier les timestamps
        if (typeof loadedState.lastUpdate === 'number' && !isNaN(loadedState.lastUpdate)) {
            sanitizedState.lastUpdate = loadedState.lastUpdate;
        }
        if (typeof loadedState.lastSave === 'number' && !isNaN(loadedState.lastSave)) {
            sanitizedState.lastSave = loadedState.lastSave;
        }
        
        // 2. Fusionner les statistiques
        if (loadedState.stats && typeof loadedState.stats === 'object') {
            Object.keys(defaultState.stats).forEach(statKey => {
                if (typeof loadedState.stats[statKey] === 'number' && !isNaN(loadedState.stats[statKey])) {
                    sanitizedState.stats[statKey] = Math.max(0, loadedState.stats[statKey]);
                }
            });
        }
        
        // 3. Fusionner les paramètres utilisateur
        if (loadedState.settings && typeof loadedState.settings === 'object') {
            // Conserver tous les paramètres du state par défaut
            Object.keys(loadedState.settings).forEach(settingKey => {
                if (settingKey in defaultState.settings) {
                    // Cas spécial pour le thème
                    if (settingKey === 'theme') {
                        sanitizedState.settings.theme = 
                            (loadedState.settings.theme === 'light' || loadedState.settings.theme === 'dark') 
                                ? loadedState.settings.theme 
                                : defaultState.settings.theme;
                    } 
                    // Cas spécial pour le thème d'accent
                    else if (settingKey === 'accentColorTheme') {
                        const validAccentThemes = ['default-blue', 'cyber-green', 'solar-orange', 'quantum-purple'];
                        sanitizedState.settings.accentColorTheme = 
                            (typeof loadedState.settings.accentColorTheme === 'string' && 
                             validAccentThemes.includes(loadedState.settings.accentColorTheme))
                                ? loadedState.settings.accentColorTheme
                                : defaultState.settings.accentColorTheme;
                    } else if (typeof loadedState.settings[settingKey] === typeof defaultState.settings[settingKey]) {
                        // Pour les autres paramètres, copier si le type correspond
                        sanitizedState.settings[settingKey] = loadedState.settings[settingKey];
                    }
                }
            });
        }
        
        // 4. Fusionner les producteurs
        if (Array.isArray(loadedState.producers)) {
            loadedState.producers.forEach((loadedProducer, index) => {
                if (loadedProducer && typeof loadedProducer === 'object' && index < sanitizedState.producers.length) {
                    const sanitizedProducer = sanitizedState.producers[index];
                    
                    // Transférer propriétés numériques avec validation
                    if (typeof loadedProducer.count === 'number' && !isNaN(loadedProducer.count)) {
                        sanitizedProducer.count = Math.max(0, loadedProducer.count);
                    }
                    
                    if (typeof loadedProducer.production === 'number' && !isNaN(loadedProducer.production) && loadedProducer.production > 0) {
                        sanitizedProducer.production = loadedProducer.production;
                    }
                    
                    if (typeof loadedProducer.costMultiplier === 'number' && !isNaN(loadedProducer.costMultiplier) && loadedProducer.costMultiplier >= 1) {
                        sanitizedProducer.costMultiplier = loadedProducer.costMultiplier;
                    }
                    
                    // État de déverrouillage
                    if (typeof loadedProducer.unlocked === 'boolean') {
                        sanitizedProducer.unlocked = loadedProducer.unlocked;
                    }
                }
            });
        }
        
        // 5. Fusionner les améliorations
        if (Array.isArray(loadedState.upgrades)) {
            loadedState.upgrades.forEach((loadedUpgrade, index) => {
                if (loadedUpgrade && typeof loadedUpgrade === 'object' && index < sanitizedState.upgrades.length) {
                    // Seul l'état d'achat est repris, les autres propriétés viennent de l'état par défaut
                    if (typeof loadedUpgrade.purchased === 'boolean') {
                        sanitizedState.upgrades[index].purchased = loadedUpgrade.purchased;
                    }
                    
                    // Conserver le coût si présent
                    if (typeof loadedUpgrade.cost === 'number' && !isNaN(loadedUpgrade.cost) && loadedUpgrade.cost > 0) {
                        sanitizedState.upgrades[index].cost = loadedUpgrade.cost;
                    }
                }
            });
        }
        
        // 6. Fusionner le système de prestige
        if (loadedState.prestige && typeof loadedState.prestige === 'object') {
            // Points et multiplicateur
            if (typeof loadedState.prestige.points === 'number' && !isNaN(loadedState.prestige.points)) {
                sanitizedState.prestige.points = Math.max(0, loadedState.prestige.points);
            }
            
            if (typeof loadedState.prestige.multiplier === 'number' && !isNaN(loadedState.prestige.multiplier)) {
                sanitizedState.prestige.multiplier = Math.max(1, loadedState.prestige.multiplier);
            }
            
            // État de déverrouillage
            if (typeof loadedState.prestige.unlocked === 'boolean') {
                sanitizedState.prestige.unlocked = loadedState.prestige.unlocked;
            }
            
            // Points à gagner
            if (typeof loadedState.prestige.toGain === 'number' && !isNaN(loadedState.prestige.toGain)) {
                sanitizedState.prestige.toGain = Math.max(0, loadedState.prestige.toGain);
            }
        }
        
        // 7. Fusionner le système d'expansion
        if (loadedState.expansion && typeof loadedState.expansion === 'object') {
            // Niveau actuel
            if (typeof loadedState.expansion.currentLevel === 'number' && !isNaN(loadedState.expansion.currentLevel)) {
                sanitizedState.expansion.currentLevel = Math.max(0, Math.min(
                    loadedState.expansion.currentLevel,
                    sanitizedState.expansion.levelNames.length - 1
                ));
            }
            
            // Progression
            if (typeof loadedState.expansion.progressToNext === 'number' && !isNaN(loadedState.expansion.progressToNext)) {
                sanitizedState.expansion.progressToNext = Math.max(0, Math.min(1, loadedState.expansion.progressToNext));
            }
            
            // État de déverrouillage
            if (typeof loadedState.expansion.unlocked === 'boolean') {
                sanitizedState.expansion.unlocked = loadedState.expansion.unlocked;
            }
            
            // Fusionner les jalons
            if (Array.isArray(loadedState.expansion.milestones)) {
                loadedState.expansion.milestones.forEach((loadedMilestone, index) => {
                    if (loadedMilestone && typeof loadedMilestone === 'object' && 
                        index < sanitizedState.expansion.milestones.length) {
                        // Seul l'état de déverrouillage est préservé, le reste vient de l'état par défaut
                        if (typeof loadedMilestone.unlocked === 'boolean') {
                            sanitizedState.expansion.milestones[index].unlocked = loadedMilestone.unlocked;
                        }
                    }
                });
            }
        }
        
        // 8. Fusionner les succès
        if (Array.isArray(loadedState.achievements)) {
            // Récupérer les états de déverrouillage des succès existants
            loadedState.achievements.forEach(loadedAchievement => {
                if (loadedAchievement && typeof loadedAchievement === 'object' && loadedAchievement.id) {
                    const matchingAchievement = sanitizedState.achievements.find(a => a.id === loadedAchievement.id);
                    if (matchingAchievement && typeof loadedAchievement.unlocked === 'boolean') {
                        matchingAchievement.unlocked = loadedAchievement.unlocked;
                    }
                }
            });
            
            // Recalculer le bonus d'achievements
            const unlockedCount = sanitizedState.achievements.filter(a => a.unlocked).length;
            sanitizedState.achievementBonus = unlockedCount;
        }
        
        // 9. Copier les boosts temporaires si présents
        if (Array.isArray(loadedState.temporaryBoosts)) {
            // Filtrer pour s'assurer que tous les boosts sont valides
            sanitizedState.temporaryBoosts = loadedState.temporaryBoosts
                .filter(boost => 
                    boost && 
                    typeof boost === 'object' && 
                    typeof boost.multiplier === 'number' && 
                    !isNaN(boost.multiplier) &&
                    typeof boost.expiryTime === 'number' && 
                    !isNaN(boost.expiryTime) &&
                    boost.expiryTime > Date.now() // Ne pas copier les boosts expirés
                )
                .map(boost => ({
                    multiplier: Math.max(1, boost.multiplier),
                    expiryTime: boost.expiryTime
                }));
        }
        
        // 10. Vérification finale des propriétés critiques
        // Si après fusion certaines structures essentielles sont toujours manquantes, les recréer
        if (!sanitizedState.expansion) {
            console.error("Structure d'expansion manquante après fusion");
            sanitizedState.expansion = JSON.parse(JSON.stringify(defaultState.expansion));
        }
        
        if (!sanitizedState.prestige) {
            console.error("Structure de prestige manquante après fusion");
            sanitizedState.prestige = JSON.parse(JSON.stringify(defaultState.prestige));
        }
        
        if (!Array.isArray(sanitizedState.producers) || sanitizedState.producers.length === 0) {
            console.error("Producteurs manquants après fusion");
            sanitizedState.producers = JSON.parse(JSON.stringify(defaultState.producers));
        }
        
        if (!Array.isArray(sanitizedState.upgrades) || sanitizedState.upgrades.length === 0) {
            console.error("Améliorations manquantes après fusion");
            sanitizedState.upgrades = JSON.parse(JSON.stringify(defaultState.upgrades));
        }
        
        console.log("Sanitization terminée avec succès");
        return sanitizedState;
        
    } catch (error) {
        console.error("Erreur lors de la sanitization de l'état du jeu:", error);
        // En cas d'erreur grave, retourner l'état par défaut
        return JSON.parse(JSON.stringify(defaultState));
    }
}

// Fonction pour obtenir un état de jeu par défaut
function getDefaultGameState() {
    // Création d'un nouvel état par défaut à chaque appel
    // en utilisant Date.now() à l'intérieur de la fonction pour garantir une valeur fraiche
    const defaultState = {
        // Valeurs de base
        nanobots: 0,
        totalNanobots: 0,
        clickValue: 1,
        lastUpdate: Date.now(),
        lastSave: Date.now(),
        
        // Flags et états du système
        gameLoopId: null,
        saveIntervalId: null,
        hasSaveLoaded: false,
        singularityActive: false,
        offlineGainNotification: null,
        
        // Statistiques de jeu
        stats: {
            clickCount: 0,
            playTime: 0,
            prestigeCount: 0,
            totalReset: 0
        },
        
        // Producteurs (générateurs de nanobots)
        producers: [
            { id: 'producer1', name: 'Nano-Assembleur', count: 0, baseCost: 10, costMultiplier: 1.1, production: 0.1, unlocked: true, 
              desc: "Assemble des nanobots individuellement", icon: "microchip" },
            { id: 'producer2', name: 'Réplicateur Moléculaire', count: 0, baseCost: 100, costMultiplier: 1.12, production: 1, unlocked: false, 
              desc: "Réplique les nanobots au niveau moléculaire", icon: "code-branch" },
            { id: 'producer3', name: 'Usine Quantique', count: 0, baseCost: 1500, costMultiplier: 1.15, production: 10, unlocked: false, 
              desc: "Utilise les fluctuations quantiques pour générer des nanobots", icon: "atom" },
            { id: 'producer4', name: 'Matrice Stellaire', count: 0, baseCost: 20000, costMultiplier: 1.17, production: 100, unlocked: false, 
              desc: "Convertit l'énergie stellaire en nanobots", icon: "sun" },
            { id: 'producer5', name: 'Condensateur Galactique', count: 0, baseCost: 500000, costMultiplier: 1.18, production: 1000, unlocked: false, 
              desc: "Condense la matière interstellaire en nanobots", icon: "galaxy" }
        ],
        
        // Améliorations
        upgrades: [
            { id: 'upgrade1', name: 'Protocole d\'auto-réplication', description: 'Double la valeur de vos clics', cost: 50, purchased: false, 
              effect: function() { game.clickValue *= 2; }, icon: "hand-pointer" },
            { id: 'upgrade2', name: 'Nano-processeurs avancés', description: 'Double la production des Nano-Assembleurs', cost: 200, purchased: false, 
              effect: function() { 
                  const producerIndex = game.producers.findIndex(p => p.id === 'producer1');
                  if (producerIndex !== -1) {
                      multiplyProducerProduction(producerIndex, 2);
                  }
              }, 
              requirement: function() {
                  const producer = game.producers.find(p => p.id === 'producer1');
                  return producer && producer.count >= 10;
              }, 
              icon: "microchip" 
            },
            { id: 'upgrade3', name: 'Algorithmes adaptatifs', description: 'Triple la production des Réplicateurs Moléculaires', cost: 1000, purchased: false, 
              effect: function() {
                  const producerIndex = game.producers.findIndex(p => p.id === 'producer2');
                  if (producerIndex !== -1) {
                      multiplyProducerProduction(producerIndex, 3);
                  }
              },
              requirement: function() {
                  const producer = game.producers.find(p => p.id === 'producer2');
                  return producer && producer.count >= 10;
              },
              icon: "brain" 
            },
            { id: 'upgrade4', name: 'Manipulation atomique', description: 'Double la production de tous les producteurs', cost: 5000, purchased: false, 
              effect: function() { applyProductionMultiplier(2); }, 
              requirement: function() { return game.totalNanobots >= 2000; }, 
              icon: "atom" 
            }
        ],
        
        // Système de prestige
        prestige: {
            unlocked: false,
            points: 0,
            multiplier: 1,
            required: 1e12, // 1 trillion
            toGain: 0
        },
        
        // Système d'expansion
        expansion: {
            unlocked: false,
            currentLevel: 0,
            progressToNext: 0,
            levelNames: [
                "Terre", "Système Solaire", "Voie Lactée", 
                "Groupe Local", "Super-amas Local", "Univers Observable",
                "Multivers", "Dimensions Parallèles", "Réalité Quantique", "Omnipresence"
            ],
            levels: [
                { name: 'Microscopic', description: 'Les nanobots se rassemblent en colonies microscopiques' },
                { name: 'Macroscopic', description: 'Les colonies deviennent visibles à l\'œil nu' },
                { name: 'Planetary', description: 'Les nanobots commencent à se répandre sur toute la planète' },
                { name: 'Interplanetary', description: 'Expansion vers d\'autres planètes du système solaire' },
                { name: 'Interstellar', description: 'Les sondes de nanobots atteignent les étoiles voisines' },
                { name: 'Galactic', description: 'Présence établie dans toute la Voie Lactée' },
                { name: 'Intergalactic', description: 'Expansion vers d\'autres galaxies' },
                { name: 'Universal', description: 'Présence dans tout l\'univers observable' },
                { name: 'Multidimensional', description: 'Découverte et exploration d\'autres dimensions' },
                { name: 'Omnipresent', description: 'Présence transcendant l\'espace et le temps' }
            ],
            milestones: [
                { id: 'milestone1', nanobotReq: 100, name: 'Premier Jalon', description: 'Débloque une voie de développement améliorée', 
                  icon: 'star', unlocked: false, effect: function() { game.clickValue += 1; } },
                { id: 'milestone2', nanobotReq: 10000, name: 'Optimisation', description: 'Optimisation du réseau de nanobots', 
                  icon: 'trophy', unlocked: false, effect: function() { game.producers[1].unlocked = true; } },
                { id: 'milestone3', nanobotReq: 1000000, name: 'Intelligence Collective', description: 'Intelligence collective émergente', 
                  icon: 'brain', unlocked: false, effect: function() { game.clickValue *= 2; } },
                { id: 'milestone4', nanobotReq: 100000000, name: 'Intégration Quantique', description: 'Intégration quantique', 
                  icon: 'atom', unlocked: false, effect: function() { game.producers[2].unlocked = true; } },
                { id: 'milestone5', nanobotReq: 10000000000, name: 'Conscience', description: 'Conscience technologique', 
                  icon: 'robot', unlocked: false, effect: function() { applyProductionMultiplier(3); } },
                { id: 'milestone6', nanobotReq: 1000000000000, name: 'Singularité', description: 'Singularité nano-technologique', 
                  icon: 'infinity', unlocked: false, effect: function() { game.prestige.unlocked = true; } }
            ]
        },
        
        // Paramètres utilisateur
        settings: {
            showAutoSaveNotification: true,
            theme: 'dark',
            accentColorTheme: 'default-blue',
            particleEffects: true,
            showTutorial: true
        },
        
        // Boosts temporaires
        temporaryBoosts: [],
        
        // Système d'accomplissements
        achievements: [
            { 
                id: 'ach1', 
                name: 'Premier Pas', 
                description: 'Produire votre premier nanobot', 
                unlocked: false, 
                icon: 'fas fa-baby',
                condition: function() { return game.nanobots >= 1; },
                rewardText: "+1% production"
            },
            { 
                id: 'ach2', 
                name: 'Automatisation', 
                description: 'Acheter votre premier producteur', 
                unlocked: false, 
                icon: 'fas fa-cog',
                condition: function() { return game.producers.some(p => p.count > 0); },
                rewardText: "+1% production"
            },
            { 
                id: 'ach3', 
                name: 'Collectionneur', 
                description: 'Posséder au moins un de chaque producteur', 
                unlocked: false, 
                icon: 'fas fa-layer-group',
                condition: function() { return game.producers.every(p => p.count > 0); },
                rewardText: "+1% production"
            },
            { 
                id: 'ach4', 
                name: 'Clicker Pro', 
                description: 'Cliquer 100 fois', 
                unlocked: false, 
                icon: 'fas fa-hand-pointer',
                condition: function() { return game.stats && game.stats.clickCount >= 100; },
                rewardText: "+1% production"
            },
            { 
                id: 'ach5', 
                name: 'Expansion', 
                description: 'Atteindre le niveau d\'expansion 3', 
                unlocked: false, 
                icon: 'fas fa-expand-arrows-alt',
                condition: function() { return game.expansion && game.expansion.currentLevel >= 3; },
                rewardText: "+1% production"
            },
            { 
                id: 'ach6', 
                name: 'Milliardaire', 
                description: 'Produire 1 milliard de nanobots', 
                unlocked: false, 
                icon: 'fas fa-money-bill-wave',
                condition: function() { return game.totalNanobots >= 1e9; },
                rewardText: "+1% production"
            },
            { 
                id: 'ach7', 
                name: 'Transcendance', 
                description: 'Effectuer votre premier prestige', 
                unlocked: false, 
                icon: 'fas fa-sync-alt',
                condition: function() { return game.prestige && game.prestige.points > 0; },
                rewardText: "+1% production"
            },
            { 
                id: 'ach8', 
                name: 'Maître de l\'Univers', 
                description: 'Atteindre le niveau d\'expansion 10', 
                unlocked: false, 
                icon: 'fas fa-globe',
                condition: function() { return game.expansion && game.expansion.currentLevel >= 10; },
                rewardText: "+1% production"
            }
        ],
        achievementBonus: 0
    };
    
    // IMPORTANT: Retourner l'état par défaut
    return defaultState;
}

// Fonction pour calculer les points de prestige à gagner
function calculatePrestigeGain() {
    try {
        // Vérifier que totalNanobots est un nombre valide
        const totalNanobots = Number(game.totalNanobots) || 0;
        
        // Protection contre les valeurs négatives
        if (totalNanobots <= 0) return 0;
        
        // Formule: racine carrée de (nanobots totaux / 1e10)
        const gain = Math.floor(Math.sqrt(totalNanobots / 1e10));
        
        // S'assurer que le gain est un nombre positif ou nul
        return (isNaN(gain) || gain < 0) ? 0 : gain;
    } catch (error) {
        console.error("Erreur dans le calcul du gain de prestige:", error);
        return 0;
    }
}

// Fonction pour appliquer un multiplicateur à la production
function applyProductionMultiplier(multiplier) {
    try {
        // Vérifier que le multiplicateur est un nombre valide et positif
        const multValue = Number(multiplier);
        if (isNaN(multValue) || multValue <= 0) {
            console.error("Multiplicateur de production invalide:", multiplier);
            return;
        }
        
        // Appliquer le multiplicateur à tous les producteurs
        if (Array.isArray(game.producers)) {
            game.producers.forEach(producer => {
                producer.production = Number(producer.production) || 0;
                producer.production *= multValue;
                
                // Protection contre NaN ou valeurs négatives
                if (isNaN(producer.production) || producer.production < 0) {
                    console.warn(`Production invalide pour ${producer.name}, réinitialisation`);
                    producer.production = 0.1; // Valeur par défaut
                }
            });
        }
    } catch (error) {
        console.error("Erreur lors de l'application du multiplicateur de production:", error);
    }
}

// Fonction pour multiplier la production d'un producteur spécifique
function multiplyProducerProduction(index, multiplier) {
    try {
        // Vérifier que l'index et le multiplicateur sont valides
        const multValue = Number(multiplier);
        if (isNaN(multValue) || multValue <= 0) {
            console.error("Multiplicateur de production invalide:", multiplier);
            return;
        }
        
        if (Array.isArray(game.producers) && index >= 0 && index < game.producers.length) {
            const producer = game.producers[index];
            producer.production = Number(producer.production) || 0;
            producer.production *= multValue;
            
            // Protection contre NaN ou valeurs négatives
            if (isNaN(producer.production) || producer.production < 0) {
                console.warn(`Production invalide pour le producteur à l'index ${index}, réinitialisation`);
                producer.production = 0.1 * Math.pow(10, index); // Valeur par défaut basée sur l'index
            }
        }
    } catch (error) {
        console.error("Erreur lors de la multiplication de la production d'un producteur:", error);
    }
}

// Fonction pour appliquer une réduction de coût
function applyCostReduction(factor) {
    try {
        // Vérifier que le facteur est un nombre valide et positif
        const factorValue = Number(factor);
        if (isNaN(factorValue) || factorValue <= 0 || factorValue > 1) {
            console.error("Facteur de réduction de coût invalide:", factor);
            return;
        }
        
        if (Array.isArray(game.producers)) {
            game.producers.forEach(producer => {
                // Assurez-vous que costMultiplier est un nombre
                producer.costMultiplier = Number(producer.costMultiplier) || 1.1;
                producer.costMultiplier = producer.costMultiplier * factorValue + (1 - factorValue);
                
                // Protection contre NaN ou valeurs trop basses/hautes
                if (isNaN(producer.costMultiplier) || producer.costMultiplier < 1.01) {
                    console.warn(`Multiplicateur de coût invalide pour ${producer.name}, réinitialisation`);
                    producer.costMultiplier = 1.1; // Valeur par défaut
                }
            });
        }
    } catch (error) {
        console.error("Erreur lors de l'application de la réduction de coût:", error);
    }
}

// Fonction pour déverrouiller un producteur
function unlockProducer(index) {
    if (index >= 0 && index < game.producers.length) {
        game.producers[index].unlocked = true;
    }
}

// Fonction pour recalculer l'intelligence collective
function recalculateCollectiveIntelligence() {
    // Compte le nombre de jalons débloqués
    const unlockedMilestones = game.expansion.milestones.filter(m => m.unlocked).length;
    // +50% par jalon débloqué
    const multiplier = 1 + (unlockedMilestones * 0.5);
    applyProductionMultiplier(multiplier);
}

// Fonction pour appliquer un boost temporaire
function applyTemporaryBoost(multiplier, durationSeconds) {
    const boost = {
        multiplier: multiplier,
        expiryTime: Date.now() + (durationSeconds * 1000)
    };
    
    game.temporaryBoosts.push(boost);
}

// Fonction pour appliquer la singularité
function applySingularity() {
    // Production x10 mais consommation de 1% des nanobots par seconde
    applyProductionMultiplier(10);
    
    // Logique de consommation implémentée dans la boucle de jeu
    game.singularityActive = true;
}

// Fonction pour vérifier et débloquer des jalons
function checkMilestones() {
    try {
        let updated = false;
        
        // Vérifier que l'expansion et ses jalons existent
        if (!game.expansion || !Array.isArray(game.expansion.milestones)) {
            console.error("Structure d'expansion invalide lors de la vérification des jalons");
            return false;
        }
        
        // Vérifier les jalons un par un
        game.expansion.milestones.forEach(milestone => {
            if (!milestone || typeof milestone !== 'object') return;
            
            // Vérifier si le jalon est déverrouillable
            if (!milestone.unlocked && 
                typeof milestone.nanobotReq === 'number' && 
                game.totalNanobots >= milestone.nanobotReq) {
                
                milestone.unlocked = true;
                updated = true;
                
                // Appliquer l'effet du jalon s'il existe
                if (typeof milestone.effect === 'function') {
                    try {
                        milestone.effect();
                    } catch (effectError) {
                        console.error(`Erreur lors de l'application de l'effet du jalon ${milestone.name}:`, effectError);
                    }
                }
                
                // Notification de déblocage
                try {
                    createNotification(`Jalon débloqué: ${milestone.name}`);
                } catch (notifError) {
                    console.error("Erreur lors de la création de notification:", notifError);
                }
            }
        });
        
        // Mettre à jour le niveau d'expansion
        try {
            updateExpansionLevel();
        } catch (expansionError) {
            console.error("Erreur lors de la mise à jour du niveau d'expansion:", expansionError);
        }
        
        return updated;
    } catch (error) {
        console.error("Erreur lors de la vérification des jalons:", error);
        return false;
    }
}

// Fonction pour mettre à jour le niveau d'expansion
function updateExpansionLevel() {
    try {
        // Vérifier que la structure d'expansion est valide
        if (!game.expansion || !Array.isArray(game.expansion.milestones) || 
            !Array.isArray(game.expansion.levelNames)) {
            console.error("Structure d'expansion invalide");
            return;
        }
        
        // Compter les jalons débloqués
        const unlockedMilestones = game.expansion.milestones.filter(m => m && m.unlocked).length;
        
        // Chaque groupe de 3 jalons débloque un nouveau niveau d'expansion
        const newLevel = Math.floor(unlockedMilestones / 3);
        
        // Limiter le niveau au nombre de noms disponibles
        const safeNewLevel = Math.min(newLevel, game.expansion.levelNames.length - 1);
        
        if (safeNewLevel > game.expansion.currentLevel) {
            game.expansion.currentLevel = safeNewLevel;
            
            // Mettre à jour l'affichage si l'élément existe
            if (elements.expansionLevel) {
                const levelName = game.expansion.levelNames[safeNewLevel] || "Niveau maximum";
                elements.expansionLevel.textContent = levelName;
            }
            
            // Si le niveau est >= 2, déverrouiller le prestige
            if (safeNewLevel >= 2 && game.prestige && !game.prestige.unlocked) {
                game.prestige.unlocked = true;
                
                // Vérifier si l'élément existe avant de modifier son style
                const prestigeSection = document.getElementById('prestige-section');
                if (prestigeSection) {
                    prestigeSection.style.display = 'block';
                }
            }
            
            // Notification de niveau
            try {
                const levelName = game.expansion.levelNames[safeNewLevel] || "Niveau maximum";
                createNotification(`Expansion atteinte: ${levelName}`);
            } catch (notifError) {
                console.error("Erreur lors de la création de notification d'expansion:", notifError);
            }
        }
        
        // Calculer la progression vers le prochain niveau
        try {
            if (safeNewLevel < game.expansion.levelNames.length - 1) {
                // Valeurs par défaut sécurisées
                const totalNanobots = Number(game.totalNanobots) || 0;
                
                // Seuils pour le niveau actuel et le suivant
                const currentThreshold = Math.pow(10, 3 + (safeNewLevel * 3)); // 1e3, 1e6, 1e9, etc.
                const nextThreshold = Math.pow(10, 3 + ((safeNewLevel + 1) * 3));
                
                // Calcul de la progression logarithmique
                const progress = (Math.log10(Math.max(totalNanobots, 1)) - Math.log10(currentThreshold)) / 
                                (Math.log10(nextThreshold) - Math.log10(currentThreshold));
                
                // S'assurer que la progression est entre 0 et 1
                const clampedProgress = Math.min(Math.max(progress, 0), 1);
                
                // Vérifier que la valeur n'est pas NaN ou Infinity
                game.expansion.progressToNext = !isNaN(clampedProgress) && isFinite(clampedProgress) 
                    ? clampedProgress : 0;
                
                // Mettre à jour l'interface si les éléments existent
                if (elements.expansionProgress) {
                    elements.expansionProgress.style.width = `${game.expansion.progressToNext * 100}%`;
                }
                if (elements.expansionPercent) {
                    elements.expansionPercent.textContent = Math.floor(game.expansion.progressToNext * 100);
                }
            } else {
                // Niveau maximum atteint
                game.expansion.progressToNext = 1;
                
                if (elements.expansionProgress) {
                    elements.expansionProgress.style.width = '100%';
                }
                if (elements.expansionPercent) {
                    elements.expansionPercent.textContent = '100';
                }
            }
        } catch (progressError) {
            console.error("Erreur lors du calcul de la progression d'expansion:", progressError);
            
            // Valeurs par défaut en cas d'erreur
            game.expansion.progressToNext = 0;
            if (elements.expansionProgress) elements.expansionProgress.style.width = '0%';
            if (elements.expansionPercent) elements.expansionPercent.textContent = '0';
        }
    } catch (error) {
        console.error("Erreur critique lors de la mise à jour du niveau d'expansion:", error);
    }
}

// Fonction pour acheter un producteur
function buyProducer(index) {
    const producer = game.producers[index];
    const cost = getProducerCost(producer);
    
    if (game.nanobots >= cost) {
        game.nanobots -= cost;
        producer.count++;
        updateUI();
        
        // Effets visuels
        createFloatingNanobots(10);
        
        // Feedback visuel (V17)
        const button = document.querySelector(`button[data-producer="${index}"]`);
        if (button) {
            createVisualFeedback(button, `+1 producteur`, 'success');
        }
    } else {
        // Feedback d'échec (V17)
        const button = document.querySelector(`button[data-producer="${index}"]`);
        if (button) {
            createVisualFeedback(button, `Ressources insuffisantes`, 'error');
        }
    }
}

// Fonction pour acheter une amélioration
function buyUpgrade(index) {
    // Vérifier que l'index est valide
    if (index < 0 || index >= game.upgrades.length) {
        console.error(`Index d'amélioration non valide: ${index}`);
        return;
    }
    
    const upgrade = game.upgrades[index];
    
    // Vérifier si l'amélioration a une condition et si elle est remplie
    if (upgrade.requirement) {
        try {
            const requirementMet = upgrade.requirement();
            if (!requirementMet) {
                return;
            }
        } catch (error) {
            console.error(`Erreur lors de l'évaluation de la condition pour ${upgrade.name}:`, error);
            return;
        }
    }
    
    if (game.nanobots >= upgrade.cost && !upgrade.purchased) {
        game.nanobots -= upgrade.cost;
        upgrade.purchased = true;
        
        try {
            upgrade.effect();
            
            // Feedback visuel (V17)
            const button = document.querySelector(`button[data-upgrade="${index}"]`);
            if (button) {
                createVisualFeedback(button, `Amélioration activée!`, 'success');
            }
        } catch (error) {
            console.error(`Erreur lors de l'application de l'effet pour ${upgrade.name}:`, error);
            // On continue même en cas d'erreur pour éviter de bloquer le jeu
        }
        
        updateUI();
        
        // Effets visuels
        createFloatingNanobots(20);
        createNotification(`Amélioration achetée: ${upgrade.name}`, 'success');
    }
}

// Fonction pour effectuer un prestige
function performPrestige() {
    const pointsToGain = calculatePrestigeGain();
    
    if (pointsToGain < 1) return;
    
    game.prestige.points += pointsToGain;
    game.prestige.multiplier = 1 + (game.prestige.points * 0.1); // +10% par point
    game.stats.prestigeCount++;
    
    // Réinitialiser le jeu tout en conservant le prestige
    game.nanobots = 0;
    game.totalNanobots = 0;
    
    // Réinitialiser les producteurs
    game.producers.forEach(producer => {
        producer.count = 0;
        producer.unlocked = producer.id === 'producer1'; // Seul le premier est déverrouillé
    });
    
    // Réinitialiser les améliorations
    game.upgrades.forEach(upgrade => {
        upgrade.purchased = false;
    });
    
    // Réinitialiser les boosts temporaires et la singularité
    game.temporaryBoosts = [];
    game.singularityActive = false;
    
    // Conserver les jalons d'expansion débloqués
    game.expansion.progressToNext = 0;
    
    // Réinitialiser le clickValue
    game.clickValue = 1;
    
    // Mettre à jour l'interface
    updateUI();
    saveGame(false); // Sauvegarde manuelle après prestige
    
    // Effets visuels
    createFloatingNanobots(100, 'rgba(156, 39, 176, 0.7)');
}

// Fonction pour créer une notification de déblocage
/**
 * Crée une notification pour informer l'utilisateur
 * @param {string} message - Le message à afficher
 * @param {string} [type='info'] - Le type de notification ('info', 'success', etc.)
 */
function createNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    // Animation d'entrée
    setTimeout(() => {
        notification.classList.add('show');
    }, 10);
    
    // Suppression automatique (plus long pour les succès)
    const duration = type === 'success' ? 5000 : 3000;
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
            notification.remove();
        }, 500);
    }, duration);
}

/**
 * Vérifie si de nouveaux succès ont été débloqués
 * @returns {boolean} - True si au moins un succès a été débloqué
 */
function checkAchievements() {
    let achievementUnlocked = false;
    
    // Parcourir tous les succès non débloqués
    game.achievements.forEach(achievement => {
        // Vérifions d'abord si la condition existe et est une fonction
        if (!achievement.unlocked && typeof achievement.condition === 'function') {
            try {
                // Entourer l'appel de la condition d'un try-catch pour éviter les erreurs
                if (achievement.condition()) {
                    // Débloquer le succès
                    achievement.unlocked = true;
                    game.achievementBonus += 1; // +1% de production par succès
                    
                    // Notifier l'utilisateur avec une notification spéciale
                    createNotification(`🏆 Succès débloqué : ${achievement.name}`, 'success');
                    
                    achievementUnlocked = true;
                }
            } catch (error) {
                console.error(`Erreur lors de la vérification du succès ${achievement.id}:`, error);
            }
        }
    });
    
    return achievementUnlocked;
}

// Fonction pour créer des nanobots flottants
function createFloatingNanobots(count, color = 'rgba(0, 229, 255, 0.7)') {
    for (let i = 0; i < count; i++) {
        setTimeout(() => {
            const nanobot = document.createElement('div');
            nanobot.className = 'floating-nanobot';
            nanobot.style.backgroundColor = color;
            nanobot.style.boxShadow = `0 0 4px ${color}`;
            
            // Position aléatoire près du centre de l'écran
            const x = window.innerWidth / 2 + (Math.random() * 200 - 100);
            const y = window.innerHeight / 2 + (Math.random() * 200 - 100);
            
            nanobot.style.left = `${x}px`;
            nanobot.style.top = `${y}px`;
            
            // Direction aléatoire
            const randomDuration = 2 + Math.random() * 2;
            const randomDelay = Math.random() * 0.5;
            nanobot.style.animation = `float-up ${randomDuration}s ease-out ${randomDelay}s forwards`;
            
            document.body.appendChild(nanobot);
            
            // Supprimer après l'animation
            setTimeout(() => {
                nanobot.remove();
            }, (randomDuration + randomDelay) * 1000);
        }, Math.random() * 500);
    }
}

// Mettre à jour l'affichage des producteurs
function updateProducers() {
    elements.producersContainer.innerHTML = '';
    
    game.producers.forEach((producer, index) => {
        // Vérifier si le producteur est déverrouillé
        if (!producer.unlocked) {
            if (game.nanobots >= producer.baseCost * 0.5 || game.totalNanobots >= producer.baseCost) {
                producer.unlocked = true;
            } else {
                return;
            }
        }
        
        const cost = getProducerCost(producer);
        const canBuy = game.nanobots >= cost;
        
        const producerElement = document.createElement('div');
        producerElement.className = 'producer-item';
        producerElement.innerHTML = `
            <div class="producer-info">
                <div class="producer-title"><i class="fas fa-${producer.icon}"></i> ${producer.name} (${producer.count})</div>
                <div class="producer-stats">
                    Produit ${formatNumber(producer.production)} nanobots/sec<br>
                    Total: ${formatNumber(producer.count * producer.production)} nanobots/sec<br>
                    <small>${producer.desc}</small>
                </div>
            </div>
            <button class="buy-button" data-producer="${index}" ${canBuy ? '' : 'disabled'}>
                ${formatNumber(cost)} <i class="fas fa-microchip"></i>
            </button>
        `;
        
        elements.producersContainer.appendChild(producerElement);
    });
    
    // Ajouter les écouteurs d'événements pour les boutons d'achat
    document.querySelectorAll('.buy-button[data-producer]').forEach(button => {
        button.addEventListener('click', function() {
            const producerIndex = parseInt(this.getAttribute('data-producer'));
            buyProducer(producerIndex);
        });
    });
}

// Mettre à jour l'affichage des améliorations
function updateUpgrades() {
    elements.upgradesContainer.innerHTML = '';
    
    // Mise à jour des améliorations
    game.upgrades.forEach((upgrade, index) => {
        // Si l'amélioration est déjà achetée, ne pas l'afficher
        if (upgrade.purchased) {
            return;
        }
        
        // Vérifier si l'amélioration a une condition de déverrouillage
        if (upgrade.requirement) {
            try {
                const requirementMet = upgrade.requirement();
                if (!requirementMet) return;
            } catch (error) {
                console.error(`Erreur lors de l'évaluation de la condition pour ${upgrade.name}:`, error);
                return;
            }
        }
        
        const canBuy = game.nanobots >= upgrade.cost;
        
        const upgradeElement = document.createElement('div');
        upgradeElement.className = 'upgrade-item';
        upgradeElement.innerHTML = `
            <div class="upgrade-info">
                <div class="upgrade-title"><i class="fas fa-${upgrade.icon}"></i> ${upgrade.name}</div>
                <div class="upgrade-desc">${upgrade.description}</div>
            </div>
            <button class="buy-button" data-upgrade="${index}" ${canBuy ? '' : 'disabled'}>
                ${formatNumber(upgrade.cost)} <i class="fas fa-microchip"></i>
            </button>
        `;
        
        elements.upgradesContainer.appendChild(upgradeElement);
    });
    
    // Ajouter les écouteurs d'événements pour les boutons d'achat
    document.querySelectorAll('.buy-button[data-upgrade]').forEach(button => {
        button.addEventListener('click', function() {
            const upgradeIndex = parseInt(this.getAttribute('data-upgrade'));
            buyUpgrade(upgradeIndex);
        });
    });
}

// Mettre à jour l'affichage des jalons
function updateMilestones() {
    elements.milestonesContainer.innerHTML = '';
    
    game.expansion.milestones.forEach((milestone, index) => {
        // N'afficher que les jalons débloqués et les prochains à débloquer
        if (!milestone.unlocked && game.totalNanobots < milestone.nanobotReq * 0.01 && index > 0) {
            // Ne pas afficher les jalons lointains
            return;
        }
        
        const milestoneElement = document.createElement('div');
        milestoneElement.className = 'milestone-item';
        
        if (milestone.unlocked) {
            milestoneElement.classList.add('unlocked');
        }
        
        // Identifier le prochain jalon à débloquer
        if (!milestone.unlocked && game.expansion.milestones[index-1]?.unlocked) {
            milestoneElement.classList.add('next');
        }
        
        milestoneElement.innerHTML = `
            <div class="milestone-icon"><i class="fas fa-${milestone.icon}"></i></div>
            <div class="milestone-name">${milestone.name}</div>
            <div class="milestone-desc">${milestone.desc}</div>
            ${!milestone.unlocked ? `<div class="milestone-req">${formatNumber(milestone.nanobotReq)} nanobots</div>` : ''}
        `;
        
        elements.milestonesContainer.appendChild(milestoneElement);
    });
}

// Mettre à jour l'affichage du prestige
function updatePrestige() {
    // Cacher la section si le prestige n'est pas encore débloqué
    document.getElementById('prestige-section').style.display = game.prestige.unlocked ? 'block' : 'none';
    
    if (!game.prestige.unlocked) return;
    
    const pointsToGain = calculatePrestigeGain();
    
    elements.prestigePoints.textContent = game.prestige.points;
    elements.prestigeMultiplier.textContent = `x${game.prestige.multiplier.toFixed(2)}`;
    elements.prestigeToGain.textContent = pointsToGain;
    
    // Activer le bouton de prestige seulement si on peut gagner au moins 1 point
    elements.prestigeButton.disabled = pointsToGain < 1;
}

// Fonction pour mettre à jour l'interface utilisateur
function updateUI() {
    // Mise à jour des compteurs principaux
    elements.nanobots.textContent = formatNumber(game.nanobots);
    elements.perSecond.textContent = formatNumber(calculateProduction());
    elements.clickValue.textContent = formatNumber(game.clickValue);
    elements.expansionLevel.textContent = game.expansion.levelNames[game.expansion.currentLevel];
    
    // Mise à jour de la barre de progression
    elements.expansionProgress.style.width = `${game.expansion.progressToNext * 100}%`;
    elements.expansionPercent.textContent = Math.floor(game.expansion.progressToNext * 100);
    
    // Mise à jour des producteurs
    updateProducers();
    
    // Mise à jour des améliorations
    updateUpgrades();
    
    // Mise à jour des jalons
    updateMilestones();
    
    // Mise à jour du prestige
    updatePrestige();
    
    // Mise à jour des succès
    updateAchievements();
}

/**
 * Mettre à jour l'affichage des succès
 */
function updateAchievements() {
    // Mettre à jour le bonus d'achievements
    elements.achievementsBonus.textContent = game.achievementBonus;
    
    // Vider le conteneur
    elements.achievementsContainer.innerHTML = '';
    
    // Afficher chaque achievement
    game.achievements.forEach(achievement => {
        const achievementElement = document.createElement('div');
        achievementElement.className = `achievement-item ${achievement.unlocked ? 'unlocked' : 'locked'}`;
        
        achievementElement.innerHTML = `
            <div class="achievement-icon"><i class="fas fa-${achievement.icon}"></i></div>
            <div class="achievement-name">${achievement.name}</div>
            <div class="achievement-desc">${achievement.description}</div>
            <div class="achievement-reward">${achievement.rewardText}</div>
        `;
        
        elements.achievementsContainer.appendChild(achievementElement);
    });
}

// Sauvegarder le jeu
/**
 * Affiche une notification discrète pour la sauvegarde automatique
 * @param {boolean} isAuto - Indique si la sauvegarde est automatique
 */
function showSaveNotification(isAuto = false) {
    // Supprime toute notification précédente
    const existingNotification = document.querySelector('.autosave-notification');
    if (existingNotification) {
        existingNotification.remove();
    }
    
    // Crée la notification
    const notification = document.createElement('div');
    notification.className = 'autosave-notification';
    notification.textContent = isAuto ? '💾 Sauvegarde auto...' : '💾 Jeu sauvegardé!';
    
    document.body.appendChild(notification);
    
    // Animation d'entrée
    setTimeout(() => {
        notification.classList.add('show');
    }, 10);
    
    // Suppression automatique
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
            notification.remove();
        }, 300);
    }, 2000);
}

/**
 * Sauvegarde l'état du jeu dans le localStorage
 * @param {boolean} isAuto - Indique si la sauvegarde est automatique
 */
function saveGame(isAuto = false) {
    // Vérification critique de l'existence de game et game.settings
    if (typeof game === 'undefined' || game === null || typeof game.settings === 'undefined') { 
        console.error('ERREUR CRITIQUE dans saveGame: L\'objet game ou game.settings est undefined. Sauvegarde annulée.', JSON.stringify(game)); 
        return false; 
    }
    
    try {
        console.log("Sauvegarde du jeu en cours...", "Type de game:", typeof game);
        
        // CORRECTION: Nous supprimons l'appel à sanitizeGameState(game)
        // car cette fonction est conçue pour fusionner un état chargé avec un état par défaut,
        // et non pour préparer un état pour la sauvegarde.
        
        // Make a clean copy to avoid circular references
        const gameToSave = JSON.parse(JSON.stringify(game));
        
        // Remove properties we don't need to save
        delete gameToSave.gameLoopId;
        delete gameToSave.offlineGainNotification;
        
        const saveData = JSON.stringify(gameToSave);
        (function() { try { return localStorage.setItem('gh_pages_nanoBotExperienceSave', saveData); } catch(e) { console.error('Erreur localStorage GitHub Pages:', e); return null; } })();
        
        // Update last save timestamp
        game.lastSave = Date.now();
        
        // Update UI if lastSave element exists
        if (elements.lastSave) {
            elements.lastSave.textContent = formatTime(game.lastSave);
        }
        
        // Show notification if appropriate
        if (!isAuto || (game.settings && game.settings.showAutoSaveNotification !== false)) {
            showSaveNotification(isAuto);
        }
        
        console.log("Jeu sauvegardé avec succès à", new Date(game.lastSave).toLocaleString());
        return true;
    } catch (error) {
        console.error("Erreur lors de la sauvegarde du jeu:", error);
        createNotification("Erreur lors de la sauvegarde du jeu!", "error");
        return false;
    }
}

// Charger le jeu
/**
 * Tente de charger la sauvegarde du jeu.
 * Si aucune sauvegarde n'est trouvée ou si elle est corrompue, initialise une nouvelle partie.
 * @returns {boolean} - true si une sauvegarde a été chargée avec succès, false sinon
 */
function loadGame() {
    const saveKey = 'nanoBotExperienceSave';
    console.log("Tentative de chargement de la sauvegarde...");
    let hasSave = false;
    
    try {
        const saveData = (function() { try { return localStorage.getItem(saveKey); } catch(e) { console.error('Erreur localStorage GitHub Pages:', e); return null; } })();
        
        // Si aucune sauvegarde n'est trouvée, initialiser avec l'état par défaut
        if (!saveData) {
            console.log("Aucune sauvegarde trouvée, initialisation d'un nouveau jeu");
            const defaultState = getDefaultGameState();
            if (!defaultState) {
                throw new Error("Échec de la récupération de l'état par défaut");
            }
            game = defaultState;
            game.hasSaveLoaded = false;
            console.log('État de game APRÈS getDefaultGameState (pas de sauvegarde):', JSON.parse(JSON.stringify(game)));
            return false;
        }
        
        hasSave = true;
        console.log("Sauvegarde trouvée, tentative de parse JSON");
        
        // Tenter de parser la sauvegarde
        let loadedState;
        try {
            loadedState = JSON.parse(saveData);
        } catch (parseError) {
            console.error("Erreur lors du parsing JSON de la sauvegarde:", parseError);
            // Sauvegarde corrompue, la supprimer
            (function() { try { return localStorage.removeItem(saveKey); } catch(e) { console.error('Erreur localStorage GitHub Pages:', e); return null; } })();
            createNotification("Sauvegarde corrompue détectée et supprimée. Démarrage d'une nouvelle partie.", "error");
            const defaultState = getDefaultGameState();
            if (!defaultState) {
                throw new Error("Échec de la récupération de l'état par défaut");
            }
            game = defaultState;
            game.hasSaveLoaded = false;
            console.log('État de game APRÈS getDefaultGameState (erreur parse):', JSON.parse(JSON.stringify(game)));
            return false;
        }
        
        // S'assurer que loadedState est bien un objet
        if (!loadedState || typeof loadedState !== 'object') {
            console.error("La sauvegarde n'est pas un objet valide");
            (function() { try { return localStorage.removeItem(saveKey); } catch(e) { console.error('Erreur localStorage GitHub Pages:', e); return null; } })();
            const defaultState = getDefaultGameState();
            if (!defaultState) {
                throw new Error("Échec de la récupération de l'état par défaut");
            }
            game = defaultState;
            game.hasSaveLoaded = false;
            console.log('État de game APRÈS getDefaultGameState (objet invalide):', JSON.parse(JSON.stringify(game)));
            return false;
        }
        
        // Obtenir un état par défaut pour la fusion
        const defaultState = getDefaultGameState();
        if (!defaultState) {
            throw new Error("Échec de la récupération de l'état par défaut");
        }
        
        // Fusionner et nettoyer l'état chargé avec notre fonction sanitize améliorée
        console.log("Fusion et sanitization de l'état du jeu chargé");
        const cleanState = sanitizeGameState(loadedState, defaultState);
        
        // Réinitialiser gameLoopId pour éviter les doublons de boucle de jeu
        cleanState.gameLoopId = null;
        cleanState.hasSaveLoaded = true;
        
        // Assigner le nouvel état propre à game
        game = cleanState;
        console.log('État de game APRÈS sanitizeGameState (chargement existant):', JSON.parse(JSON.stringify(game)));
        
        // Appliquer le thème d'accent sauvegardé
        if (game.settings && typeof game.settings.accentColorTheme === 'string') {
            applyAccentColorTheme(game.settings.accentColorTheme);
        }
        
        // Calcul des gains hors ligne
        const currentTime = Date.now();
        const lastUpdate = Number(game.lastUpdate) || currentTime;
        const offlineTime = Math.max(0, (currentTime - lastUpdate) / 1000); // en secondes
        
        if (offlineTime > 10) { // Si plus de 10 secondes se sont écoulées
            try {
                const production = calculateProduction();
                const offlineGain = production * offlineTime;
                
                if (!isNaN(offlineGain) && isFinite(offlineGain) && offlineGain > 0) {
                    game.nanobots += offlineGain;
                    game.totalNanobots += offlineGain;
                    
                    // Vérification des nouveaux jalons
                    checkMilestones();
                    
                    // Stocker le message pour l'afficher plus tard
                    game.offlineGainNotification = `Vous avez gagné ${formatNumber(offlineGain)} nanobots pendant votre absence!`;
                }
            } catch (offlineError) {
                console.error("Erreur lors du calcul des gains hors ligne:", offlineError);
            }
        }
        
        // Mise à jour du temps
        game.lastUpdate = currentTime;
        
        console.log('Jeu chargé avec succès!');
        return true; // Indique qu'une sauvegarde a été chargée avec succès
    } catch (error) {
        console.error('Erreur critique lors du chargement de la sauvegarde:', error);
        
        // En cas d'erreur grave, supprimer la sauvegarde corrompue
        if (hasSave) {
            (function() { try { return localStorage.removeItem(saveKey); } catch(e) { console.error('Erreur localStorage GitHub Pages:', e); return null; } })();
            createNotification("Erreur lors du chargement de la sauvegarde. La sauvegarde a été supprimée.", "error");
        }
        
        // Initialiser avec un état par défaut propre
        const defaultState = getDefaultGameState();
        if (!defaultState) {
            console.error("État par défaut non disponible après erreur critique");
            // Dernier recours: créer un état minimal
            game = {
                nanobots: 0,
                totalNanobots: 0,
                clickValue: 1,
                lastUpdate: Date.now(),
                producers: [],
                upgrades: [],
                hasSaveLoaded: false
            };
        } else {
            game = defaultState;
            game.hasSaveLoaded = false;
        }
        
        // Vérification finale de game à la fin de loadGame
        if (typeof game === 'undefined' || game === null) { 
            console.error('ERREUR CRITIQUE: game est undefined à la fin de loadGame!'); 
            game = getDefaultGameState(); 
            console.log('game réinitialisé à default dans loadGame pour éviter undefined.'); 
        } else { 
            console.log('Fin de loadGame, état de game:', JSON.parse(JSON.stringify(game))); 
        }
        
        return false;
    }
}

// Réinitialiser le jeu
function resetGame() {
    if (confirm('Êtes-vous sûr de vouloir réinitialiser tout le jeu? Vous perdrez toute votre progression, y compris les points d\'évolution!')) {
        // Arrêter la boucle de jeu actuelle
        stopGameLoop();
        
        // Supprimer la sauvegarde du localStorage
        (function() { try { return localStorage.removeItem('gh_pages_nanoBotExperienceSave'); } catch(e) { console.error('Erreur localStorage GitHub Pages:', e); return null; } })();
        
        // Démarrer une nouvelle partie
        startNewGame();
    }
}

// Boucle principale du jeu
function gameLoop() {
    try {
        // Validation de la structure de base du jeu
        if (!game || typeof game !== 'object') {
            console.error("Structure de jeu invalide dans gameLoop");
            return;
        }
        
        // Obtenir le timestamp actuel et calculer le delta temps
        const currentTime = Date.now();
        const lastUpdate = Number(game.lastUpdate) || currentTime;
        
        // Limiter deltaTime à 60 secondes max pour éviter les grands sauts en cas de mise en pause prolongée
        const deltaTime = Math.min((currentTime - lastUpdate) / 1000, 60);
        
        // Calculer la production actuelle (avec protection contre NaN)
        let production = 0;
        try {
            production = calculateProduction();
        } catch (prodError) {
            console.error("Erreur lors du calcul de la production:", prodError);
        }
        
        // Mise à jour des ressources avec protection contre NaN et valeurs négatives
        if (!isNaN(production) && isFinite(production) && production >= 0) {
            // Incrémenter les nanobots avec protection contre NaN
            const nanobotsGain = production * deltaTime;
            if (!isNaN(nanobotsGain) && isFinite(nanobotsGain)) {
                game.nanobots = Number(game.nanobots) || 0;
                game.nanobots += nanobotsGain;
                
                game.totalNanobots = Number(game.totalNanobots) || 0;
                game.totalNanobots += nanobotsGain;
            }
        }
        
        // Assurer que les valeurs ne deviennent jamais NaN
        if (isNaN(game.nanobots) || !isFinite(game.nanobots)) {
            console.error("Valeur de nanobots invalide détectée:", game.nanobots);
            game.nanobots = 0;
        }
        
        if (isNaN(game.totalNanobots) || !isFinite(game.totalNanobots)) {
            console.error("Valeur de totalNanobots invalide détectée:", game.totalNanobots);
            game.totalNanobots = 0;
        }
        
        // Appliquer la singularité si active (consomme 1% des nanobots par seconde)
        if (game.singularityActive) {
            try {
                const consumption = game.nanobots * 0.01 * deltaTime;
                if (!isNaN(consumption) && isFinite(consumption)) {
                    game.nanobots = Math.max(0, game.nanobots - consumption);
                }
            } catch (singularityError) {
                console.error("Erreur lors de l'application de la singularité:", singularityError);
            }
        }
        
        // Nettoyer les boosts temporaires expirés
        try {
            if (Array.isArray(game.temporaryBoosts)) {
                game.temporaryBoosts = game.temporaryBoosts.filter(boost => 
                    boost && typeof boost === 'object' && Number(boost.expiryTime) > currentTime);
            } else {
                game.temporaryBoosts = [];
            }
        } catch (boostError) {
            console.error("Erreur lors du nettoyage des boosts temporaires:", boostError);
            game.temporaryBoosts = [];
        }
        
        // Initialiser les flags de mise à jour
        let achievementsUpdated = false;
        let milestonesUpdated = false;
        let needUIUpdate = false;
        
        // Vérifier et débloquer des succès
        try {
            achievementsUpdated = checkAchievements();
        } catch (achievementError) {
            console.error("Erreur lors de la vérification des succès:", achievementError);
        }
        
        // Vérifier et débloquer des jalons
        try {
            milestonesUpdated = checkMilestones();
        } catch (milestoneError) {
            console.error("Erreur lors de la vérification des jalons:", milestoneError);
        }
        
        // Mettre à jour l'interface si nécessaire
        if (milestonesUpdated || achievementsUpdated) {
            try {
                updateUI();
            } catch (uiError) {
                console.error("Erreur lors de la mise à jour de l'interface:", uiError);
            }
        } else {
            // Mise à jour minimale des affichages qui changent constamment
            try {
                if (elements.nanobots) {
                    elements.nanobots.textContent = formatNumber(game.nanobots);
                }
                if (elements.perSecond) {
                    elements.perSecond.textContent = formatNumber(production);
                }
                
                // Vérification des déverrouillages (producteurs et améliorations)
                if (Array.isArray(game.producers)) {
                    game.producers.forEach(producer => {
                        if (producer && typeof producer === 'object' && 
                            !producer.unlocked && 
                            ((game.nanobots >= producer.baseCost * 0.5) || 
                             (game.totalNanobots >= producer.baseCost))) {
                            producer.unlocked = true;
                            needUIUpdate = true;
                        }
                    });
                }
                
                // Mise à jour des points de prestige à gagner
                if (game.prestige) {
                    try {
                        const newPrestigeToGain = calculatePrestigeGain();
                        if (game.prestige.toGain !== newPrestigeToGain) {
                            game.prestige.toGain = newPrestigeToGain;
                            
                            if (elements.prestigeToGain) {
                                elements.prestigeToGain.textContent = newPrestigeToGain;
                            }
                            if (elements.prestigeButton) {
                                elements.prestigeButton.disabled = newPrestigeToGain < 1;
                            }
                        }
                    } catch (prestigeError) {
                        console.error("Erreur lors du calcul des points de prestige:", prestigeError);
                    }
                }
                
                // Mise à jour complète de l'interface si nécessaire
                if (needUIUpdate) {
                    try {
                        updateUI();
                    } catch (uiUpdateError) {
                        console.error("Erreur lors de la mise à jour complète de l'interface:", uiUpdateError);
                    }
                }
            } catch (minUpdateError) {
                console.error("Erreur lors de la mise à jour minimale:", minUpdateError);
            }
        }
        
        // Sauvegarde automatique toutes les 30 secondes
        try {
            const lastSave = Number(game.lastSave) || 0;
            if (currentTime - lastSave > 30000) { // 30000 ms = 30 secondes
                saveGame(true); // Passe 'true' pour indiquer que c'est une sauvegarde automatique
            }
        } catch (saveError) {
            console.error("Erreur lors de la sauvegarde automatique:", saveError);
        }
        
        // Mise à jour du temps
        game.lastUpdate = currentTime;
        
        // Mise à jour du temps de jeu
        if (game.stats) {
            game.stats.playTime = Number(game.stats.playTime) || 0;
            game.stats.playTime += deltaTime;
        }
        
        // Continuer la boucle de jeu avec requestAnimationFrame
        game.gameLoopId = requestAnimationFrame(gameLoop);
        
    } catch (criticalError) {
        console.error("Erreur critique dans la boucle de jeu:", criticalError);
        
        // Continuer la boucle malgré l'erreur pour éviter que le jeu ne se fige
        game.gameLoopId = requestAnimationFrame(gameLoop);
    }
}

// Initialisation
// Fonctions pour le changement de thème
/**
 * Applique le thème de base (clair/sombre) de l'interface
 * @param {string} theme - Le thème à appliquer ('light' ou 'dark')
 */
function applyTheme(theme) {
    try {
        // Vérifier que le thème est valide, sinon utiliser le thème sombre par défaut
        if (theme !== 'light' && theme !== 'dark') {
            console.warn(`Thème invalide: ${theme}, utilisation du thème sombre par défaut`);
            theme = 'dark';
        }
        
        // Appliquer la classe CSS appropriée
        if (theme === 'light') {
            document.documentElement.classList.add('light-theme');
        } else {
            document.documentElement.classList.remove('light-theme');
        }
        
        // Mettre à jour l'icône du bouton de changement de thème
        if (elements.themeToggle) {
            try {
                const iconElement = elements.themeToggle.querySelector('i');
                if (iconElement) {
                    iconElement.className = theme === 'light' ? 'fas fa-sun' : 'fas fa-moon';
                }
            } catch (iconError) {
                console.error("Erreur lors de la mise à jour de l'icône de thème:", iconError);
            }
        }
        
        // S'assurer que game.settings existe
        if (!game.settings) {
            game.settings = {};
        }
        
        // Mettre à jour le paramètre de thème
        game.settings.theme = theme;
        
        return true;
    } catch (error) {
        console.error("Erreur lors de l'application du thème:", error);
        return false;
    }
}

/**
 * Applique le thème de couleur d'accent à l'interface
 * @param {string} themeName - Le nom du thème d'accent ('default-blue', 'cyber-green', etc.)
 */
function applyAccentColorTheme(themeName) {
    try {
        console.log(`Application du thème d'accent: ${themeName}`);
        
        // Valider le thème
        const validThemes = ['default-blue', 'cyber-green', 'solar-orange', 'quantum-purple'];
        if (!validThemes.includes(themeName)) {
            console.warn(`Thème d'accent invalide: ${themeName}, utilisation du thème par défaut`);
            themeName = 'default-blue';
        }
        
        // Enlever toutes les classes de thème d'accent existantes
        validThemes.forEach(theme => {
            document.body.classList.remove(`theme-${theme}`);
        });
        
        // Si le thème n'est pas le défaut, ajouter la classe correspondante
        if (themeName !== 'default-blue') {
            document.body.classList.add(`theme-${themeName}`);
        }
        
        // Mettre à jour l'état actif des boutons de sélection de couleur
        const colorButtons = document.querySelectorAll('.color-option');
        colorButtons.forEach(button => {
            if (button.getAttribute('data-theme') === themeName) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
        });
        
        // Mettre à jour le thème dans les paramètres du jeu
        if (game && game.settings) {
            game.settings.accentColorTheme = themeName;
            
            // Sauvegarder les paramètres si c'est un changement manuel (pas au chargement)
            if (game.hasSaveLoaded) {
                saveGame();
            }
        }
        
        return true;
    } catch (error) {
        console.error("Erreur lors de l'application du thème d'accent:", error);
        return false;
    }
}

/**
 * Initialise les boutons de sélection de thème d'accent
 */
function setupAccentColorPicker() {
    try {
        const colorButtons = document.querySelectorAll('.color-option');
        
        // Appliquer le thème actuel pour mettre en évidence le bouton correspondant
        if (game && game.settings && game.settings.accentColorTheme) {
            applyAccentColorTheme(game.settings.accentColorTheme);
        }
        
        // Ajouter les écouteurs d'événements aux boutons
        colorButtons.forEach(button => {
            button.addEventListener('click', function() {
                const selectedTheme = this.getAttribute('data-theme');
                applyAccentColorTheme(selectedTheme);
            });
        });
        
        console.log('Sélecteur de couleurs initialisé');
        return true;
    } catch (error) {
        console.error("Erreur lors de l'initialisation du sélecteur de couleurs:", error);
        return false;
    }
}

function toggleTheme() {
    try {
        // S'assurer que game.settings existe
        if (!game.settings) {
            game.settings = { theme: 'dark' };
        }
        
        // Déterminer le nouveau thème
        const currentTheme = game.settings.theme || 'dark';
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        
        // Appliquer le nouveau thème
        if (applyTheme(newTheme)) {
            createNotification(`Thème ${newTheme === 'light' ? 'clair' : 'sombre'} activé`, 'info');
        }
        
        // Sauvegarder les préférences
        try {
            saveGame(true); // Sauvegarde silencieuse après changement de thème
        } catch (saveError) {
            console.error("Erreur lors de la sauvegarde des préférences de thème:", saveError);
        }
    } catch (error) {
        console.error("Erreur lors du changement de thème:", error);
    }
}

// Fonction pour configurer les boutons et fonctionnalités
function setupGameControls() {
    // Écouteurs d'événements pour les contrôles de jeu
    if (elements.clicker) {
        elements.clicker.addEventListener('click', () => {
            // Ajouter la valeur du clic
            game.nanobots += game.clickValue * game.prestige.multiplier;
            game.totalNanobots += game.clickValue * game.prestige.multiplier;
            game.stats.clickCount++;
            
            // Effet d'animation
            elements.nanobots.classList.add('nanobot-gain');
            setTimeout(() => {
                elements.nanobots.classList.remove('nanobot-gain');
            }, 500);
            
            // Créer des nanobots flottants
            createFloatingNanobots(3);
            
            // Mise à jour immédiate
            elements.nanobots.textContent = formatNumber(game.nanobots);
            
            // Vérifier les jalons et les succès
            const achievementsUpdated = checkAchievements();
            const milestonesUpdated = checkMilestones();
            
            if (milestonesUpdated || achievementsUpdated) {
                updateUI();
            }
        });
    }
    
    if (elements.saveButton) elements.saveButton.addEventListener('click', () => saveGame(false));
    if (elements.resetButton) elements.resetButton.addEventListener('click', resetGame);
    if (elements.prestigeButton) elements.prestigeButton.addEventListener('click', performPrestige);
    if (elements.themeToggle) elements.themeToggle.addEventListener('click', toggleTheme);
}

// Fonction pour afficher les options de démarrage
function showStartOptions() {
    const loadingScreen = document.getElementById('loading-screen');
    const loadingText = document.getElementById('loading-text');
    const startOptions = document.getElementById('start-options');
    const continueButton = document.getElementById('continue-button');
    const newGameButton = document.getElementById('new-game-button');
    
    // Masquer le spinner
    document.querySelector('.spinner').style.display = 'none';
    
    // Mettre à jour le texte de chargement
    loadingText.textContent = 'Nano Bot Experience';
    
    // Vérifier si une sauvegarde existe
    const hasSave = (function() { try { return localStorage.getItem('gh_pages_nanoBotExperienceSave'); } catch(e) { console.error('Erreur localStorage GitHub Pages:', e); return null; } })() !== null;
    
    // Afficher ou masquer le bouton continuer selon l'existence d'une sauvegarde
    if (hasSave) {
        continueButton.style.display = 'block';
        // Ajouter la classe d'avertissement au bouton nouvelle partie
        newGameButton.classList.add('warning');
    } else {
        continueButton.style.display = 'none';
        // Enlever la classe d'avertissement car il n'y a pas de sauvegarde à écraser
        newGameButton.classList.remove('warning');
    }
    
    // Afficher les options de démarrage
    startOptions.style.display = 'flex';
    
    // Ajouter une transition pour l'apparition progressive
    setTimeout(() => {
        startOptions.classList.add('show');
    }, 100);
    
    // Ajouter les écouteurs d'événements aux boutons
    continueButton.addEventListener('click', proceedToGame);
    
    newGameButton.addEventListener('click', () => {
        if (hasSave) {
            // Demander confirmation si une sauvegarde existe
            if (confirm('Êtes-vous sûr de vouloir commencer une nouvelle partie ? Votre progression actuelle sera perdue.')) {
                startNewGame();
            }
        } else {
            startNewGame();
        }
    });
}

// Fonction pour démarrer une nouvelle partie
/**
 * Démarre une nouvelle partie.
 * Réinitialise complètement l'état du jeu et démarre une nouvelle partie.
 */
function startNewGame() {
    console.log("Démarrage d'une nouvelle partie...");
    
    try {
        // S'assurer que la boucle de jeu précédente est arrêtée
        stopGameLoop();
        
        // Supprimer l'ancienne sauvegarde si elle existe
        (function() { try { return localStorage.removeItem('gh_pages_nanoBotExperienceSave'); } catch(e) { console.error('Erreur localStorage GitHub Pages:', e); return null; } })();
        
        // Obtenir un nouvel état de jeu par défaut
        const defaultState = getDefaultGameState();
        
        // Vérifier que l'état par défaut est valide
        if (!defaultState || typeof defaultState !== 'object') {
            throw new Error("État par défaut invalide obtenu");
        }
        
        // Assigner le nouvel état au jeu
        game = defaultState;
        game.hasSaveLoaded = false;
        
        console.log("Nouveau jeu initialisé avec état par défaut");
        console.log('État de game APRÈS getDefaultGameState dans startNewGame:', JSON.parse(JSON.stringify(game)));
        
        // Appliquer le thème d'accent par défaut
        if (game.settings && typeof game.settings.accentColorTheme === 'string') {
            applyAccentColorTheme(game.settings.accentColorTheme);
        }
        
        // Vérifier que game est valide avant la sauvegarde
        if (typeof game === 'undefined' || game === null || typeof game.settings === 'undefined') { 
            console.error('ERREUR CRITIQUE: game ou game.settings undefined AVANT saveGame dans startNewGame!'); 
            return; 
        }
        
        // Sauvegarder immédiatement le nouvel état
        try {
            saveGame(true);
        } catch (saveError) {
            console.error("Erreur lors de la sauvegarde initiale:", saveError);
            // Continue même en cas d'erreur de sauvegarde
        }
        
        // Continuer vers le jeu
        proceedToGame();
        
        // Afficher un message de bienvenue
        setTimeout(() => {
            createNotification('Bienvenue dans Nano Bot Experience!', 'success');
        }, 1000);
    } catch (error) {
        console.error("Erreur critique lors du démarrage d'une nouvelle partie:", error);
        
        // En cas d'erreur grave, créer un état minimal
        game = {
            nanobots: 0,
            totalNanobots: 0,
            clickValue: 1,
            lastUpdate: Date.now(),
            producers: [],
            upgrades: [],
            hasSaveLoaded: false
        };
        
        // Tenter de continuer malgré tout
        proceedToGame();
        
        createNotification("Une erreur est survenue lors du démarrage. Le jeu pourrait ne pas fonctionner correctement.", "error");
    }
}

// Fonction pour continuer vers le jeu (après nouvelle partie ou chargement)
/**
 * Continue vers l'écran de jeu principal après le chargement ou la création d'une partie.
 * Configure l'interface et démarre la boucle de jeu.
 */
function proceedToGame() {
    console.log("Passage au jeu principal...");
    
    try {
        // Vérifier que l'état du jeu est valide
        if (!game || typeof game !== 'object') {
            throw new Error("État du jeu invalide");
        }
        
        // Vérifier que les structures essentielles existent
        if (!game.producers || !game.upgrades || !game.prestige || !game.expansion) {
            console.error("Structures essentielles manquantes dans l'état du jeu");
            
            // Tentative de récupération: obtenir un état par défaut
            const defaultState = getDefaultGameState();
            if (defaultState) {
                // Sauvegarder les ressources actuelles si elles existent
                const nanobots = typeof game.nanobots === 'number' ? game.nanobots : 0;
                const totalNanobots = typeof game.totalNanobots === 'number' ? game.totalNanobots : 0;
                
                // Réinitialiser le jeu avec l'état par défaut
                game = defaultState;
                
                // Restaurer les ressources
                game.nanobots = nanobots;
                game.totalNanobots = totalNanobots;
                
                console.log("État du jeu récupéré avec l'état par défaut");
            } else {
                throw new Error("Impossible de récupérer l'état du jeu");
            }
        }
        
        const loadingScreen = document.getElementById('loading-screen');
        const gameContainer = document.querySelector('.game-container');
        
        if (!loadingScreen || !gameContainer) {
            console.error("Éléments d'interface introuvables");
        }
        
        // S'assurer que la boucle de jeu précédente est arrêtée
        stopGameLoop();
        
        try {
            // Cacher la section de prestige jusqu'au déverrouillage
            const prestigeSection = document.getElementById('prestige-section');
            if (prestigeSection) {
                prestigeSection.style.display = game.prestige && game.prestige.unlocked ? 'block' : 'none';
            }
            
            // S'assurer que le thème est correctement appliqué
            if (game.settings && typeof game.settings.theme === 'string') {
                applyTheme(game.settings.theme);
            } else {
                applyTheme('dark'); // Thème par défaut
            }
            
            // Mettre à jour l'interface avec l'état actuel du jeu
            updateUI();
            
            // Configurer les contrôles du jeu
            setupGameControls();
        } catch (uiError) {
            console.error("Erreur lors de la configuration de l'interface:", uiError);
            // Continue malgré les erreurs d'interface
        }
        
        // Initialiser le sélecteur de couleurs
        setupAccentColorPicker();
        
        // Démarrer la boucle de jeu (s'assurer qu'elle n'est pas déjà en cours)
        console.log("Démarrage de la boucle de jeu");
        if (!game.gameLoopId) {
            game.gameLoopId = requestAnimationFrame(gameLoop);
        }
        
        // Transition vers le jeu
        if (loadingScreen) {
            loadingScreen.classList.add('hidden');
        }
        
        // Afficher le conteneur du jeu après un court délai pour la transition
        setTimeout(() => {
            if (gameContainer) {
                gameContainer.style.display = 'flex';
            }
            
            // Afficher le message de gain hors ligne s'il existe
            if (game.offlineGainNotification) {
                createNotification(game.offlineGainNotification);
                delete game.offlineGainNotification;
            }
        }, 500);
    } catch (error) {
        console.error("Erreur critique lors du passage au jeu principal:", error);
        
        // Tentative de récupération d'urgence
        try {
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
                loadingScreen.classList.add('hidden');
            }
            
            const gameContainer = document.querySelector('.game-container');
            if (gameContainer) {
                gameContainer.style.display = 'flex';
            }
            
            // Créer un état minimal et redémarrer
            game = getDefaultGameState() || {
                nanobots: 0,
                totalNanobots: 0,
                clickValue: 1,
                producers: [],
                upgrades: [],
                prestige: { unlocked: false, points: 0, multiplier: 1 },
                expansion: { currentLevel: 0, progressToNext: 0 },
                lastUpdate: Date.now()
            };
            
            // Forcer l'interface à se mettre à jour
            updateUI();
            
            // Démarrer une boucle de jeu d'urgence
            game.gameLoopId = requestAnimationFrame(gameLoop);
            
            createNotification("Une erreur critique est survenue. Le jeu a été réinitialisé.", "error");
        } catch (recoveryError) {
            console.error("Échec de la récupération d'urgence:", recoveryError);
            alert("Erreur critique. Veuillez recharger la page.");
        }
    }
}

// Fonction d'initialisation des éléments DOM
/**
 * Cette fonction garantit que les éléments de l'interface sont correctement liés.
 */
function initializeElements() {
    try {
        // Recharger tous les éléments du DOM
        window.elements = {
            nanobots: document.getElementById('nanobots') || document.createElement('div'),
            perSecond: document.getElementById('per-second') || document.createElement('div'),
            clickValue: document.getElementById('click-value') || document.createElement('div'),
            expansionLevel: document.getElementById('expansion-level') || document.createElement('div'),
            expansionProgress: document.getElementById('expansion-progress') || document.createElement('div'),
            expansionPercent: document.getElementById('expansion-percent') || document.createElement('div'),
            clicker: document.getElementById('clicker') || document.createElement('div'),
            producersContainer: document.getElementById('producers-container') || document.createElement('div'),
            upgradesContainer: document.getElementById('upgrades-container') || document.createElement('div'),
            milestonesContainer: document.getElementById('milestones-container') || document.createElement('div'),
            prestigePoints: document.getElementById('prestige-points') || document.createElement('div'),
            prestigeMultiplier: document.getElementById('prestige-multiplier') || document.createElement('div'),
            prestigeToGain: document.getElementById('prestige-to-gain') || document.createElement('div'),
            prestigeButton: document.getElementById('prestige-button') || document.createElement('button'),
            saveButton: document.getElementById('save-button') || document.createElement('button'),
            resetButton: document.getElementById('reset-button') || document.createElement('button'),
            themeToggle: document.getElementById('theme-toggle') || document.createElement('button'),
            lastSave: document.getElementById('last-save') || document.createElement('div'),
            achievementsContainer: document.getElementById('achievements-container') || document.createElement('div'),
            achievementsBonus: document.getElementById('achievements-bonus') || document.createElement('div')
        };
        
        console.log("Éléments DOM initialisés avec succès");
    } catch (error) {
        console.error("Erreur lors de l'initialisation des éléments DOM:", error);
    }
}

// Système de menu et fonctionnalités associées
// ===============================================

// Variables globales pour le menu
let hasSaveData = false;
let menuInitialized = false;
let audioContext;
let audioSource;
let analyser;
let dataArray;
let animationFrameId;
let lastSaveInfo = '';

// Initialiser le menu principal
function initializeMenu() {
    if (menuInitialized) return;
    
    try {
        console.log("Initialisation du menu...");
        
        // Éléments du DOM
        const mainMenu = document.getElementById('main-menu');
        const settingsMenu = document.getElementById('settings-menu');
        const versionNotesMenu = document.getElementById('version-notes-menu');
        const loadingOverlay = document.getElementById('loading-overlay');
        const gameContainer = document.querySelector('.game-container');
        const saveDetails = document.getElementById('save-details');
        
        // Boutons du menu
        const continueGameBtn = document.getElementById('continue-game');
        const newGameBtn = document.getElementById('new-game');
        const openSettingsBtn = document.getElementById('open-settings');
        const showVersionNotesBtn = document.getElementById('show-version-notes');
        
        // Boutons retour
        const settingsBackBtn = document.getElementById('settings-back');
        const versionNotesBackBtn = document.getElementById('version-notes-back');
        
        // Boutons paramètres
        const musicToggle = document.getElementById('music-toggle');
        const volumeSlider = document.getElementById('volume-slider');
        const visualizerToggle = document.getElementById('visualizer-toggle');
        const darkThemeToggle = document.getElementById('dark-theme-toggle');
        const particlesToggle = document.getElementById('particles-toggle');
        const notificationsToggle = document.getElementById('notifications-toggle');
        const autosaveToggle = document.getElementById('autosave-toggle');
        const resetGameButton = document.getElementById('reset-game-button');
        
        // Vérifier s'il existe une sauvegarde
        hasSaveData = (function() { try { return localStorage.getItem('gh_pages_nanoBotExperienceSave'); } catch(e) { console.error('Erreur localStorage GitHub Pages:', e); return null; } })() !== null;
        
        // Mettre à jour le bouton continuer
        updateContinueButton();
        
        // Initialiser les particules
        createMenuParticles();
        
        // Ajouter les écouteurs d'événements
        
        // Menu principal
        continueGameBtn.addEventListener('click', () => {
            if (hasSaveData) {
                startGame(true);
            }
        });
        
        newGameBtn.addEventListener('click', () => {
            confirmNewGame();
        });
        
        openSettingsBtn.addEventListener('click', () => {
            mainMenu.classList.add('hidden');
            settingsMenu.classList.remove('hidden');
            loadSettings();
        });
        
        showVersionNotesBtn.addEventListener('click', () => {
            mainMenu.classList.add('hidden');
            versionNotesMenu.classList.remove('hidden');
        });
        
        // Boutons retour
        settingsBackBtn.addEventListener('click', () => {
            settingsMenu.classList.add('hidden');
            mainMenu.classList.remove('hidden');
        });
        
        versionNotesBackBtn.addEventListener('click', () => {
            versionNotesMenu.classList.add('hidden');
            mainMenu.classList.remove('hidden');
        });
        
        // Contrôles audio
        if (musicToggle) {
            musicToggle.addEventListener('change', () => {
                toggleBackgroundMusic(musicToggle.checked);
            });
        }
        
        if (volumeSlider) {
            volumeSlider.addEventListener('input', () => {
                const volume = volumeSlider.value / 100;
                const volumeValue = document.getElementById('volume-value');
                if (volumeValue) {
                    volumeValue.textContent = volumeSlider.value + '%';
                }
                setMusicVolume(volume);
            });
        }
        
        if (visualizerToggle) {
            visualizerToggle.addEventListener('change', () => {
                toggleAudioVisualizer(visualizerToggle.checked);
            });
        }
        
        // Paramètres d'interface
        if (darkThemeToggle) {
            darkThemeToggle.addEventListener('change', () => {
                applyTheme(darkThemeToggle.checked ? 'dark' : 'light');
            });
        }
        
        if (particlesToggle) {
            particlesToggle.addEventListener('change', () => {
                toggleParticles(particlesToggle.checked);
            });
        }
        
        if (notificationsToggle) {
            notificationsToggle.addEventListener('change', () => {
                // Mettre à jour les paramètres
                if (game && game.settings) {
                    game.settings.showAutoSaveNotification = notificationsToggle.checked;
                }
            });
        }
        
        // Paramètres de sauvegarde
        if (autosaveToggle) {
            autosaveToggle.addEventListener('change', () => {
                toggleAutoSave(autosaveToggle.checked);
            });
        }
        
        if (resetGameButton) {
            resetGameButton.addEventListener('click', () => {
                confirmResetGame();
            });
        }
        
        // Initialiser le système audio
        initializeAudioSystem();
        
        menuInitialized = true;
        console.log("Menu initialisé avec succès");
    } catch (error) {
        console.error("Erreur lors de l'initialisation du menu:", error);
    }
}

// Mettre à jour le bouton continuer avec les infos de sauvegarde
function updateContinueButton() {
    const continueGameBtn = document.getElementById('continue-game');
    const saveDetails = document.getElementById('save-details');
    
    if (!continueGameBtn || !saveDetails) return;
    
    try {
        // Vérifier s'il existe une sauvegarde
        const saveData = (function() { try { return localStorage.getItem('gh_pages_nanoBotExperienceSave'); } catch(e) { console.error('Erreur localStorage GitHub Pages:', e); return null; } })();
        
        if (saveData) {
            hasSaveData = true;
            continueGameBtn.classList.remove('disabled');
            
            // Extraire les informations de sauvegarde
            try {
                const savedGame = JSON.parse(saveData);
                
                if (savedGame) {
                    // Formatage date/heure
                    const saveDate = new Date(savedGame.lastSave);
                    const formattedDate = saveDate.toLocaleDateString();
                    const formattedTime = saveDate.toLocaleTimeString();
                    
                    // Construire le texte d'info
                    lastSaveInfo = `Dernière sauvegarde: ${formattedDate} à ${formattedTime}`;
                    
                    // Ajouter des infos de progression
                    const nanobotsFormatted = formatNumber(savedGame.nanobots);
                    lastSaveInfo += `<br>${nanobotsFormatted} nanobots`;
                    
                    if (savedGame.expansion && savedGame.expansion.currentLevel !== undefined) {
                        const levelName = savedGame.expansion.levelNames?.[savedGame.expansion.currentLevel] || `Niveau ${savedGame.expansion.currentLevel}`;
                        lastSaveInfo += `<br>Zone: ${levelName}`;
                    }
                    
                    saveDetails.innerHTML = lastSaveInfo;
                }
            } catch (parseError) {
                console.error("Erreur lors de l'analyse des données de sauvegarde:", parseError);
                saveDetails.textContent = "Sauvegarde disponible";
            }
        } else {
            hasSaveData = false;
            continueGameBtn.classList.add('disabled');
            saveDetails.textContent = "Aucune sauvegarde trouvée";
        }
    } catch (error) {
        console.error("Erreur lors de la mise à jour du bouton continuer:", error);
    }
}

// Créer des particules pour le menu
function createMenuParticles() {
    const menuParticles = document.getElementById('menu-particles');
    
    if (!menuParticles) return;
    
    try {
        menuParticles.innerHTML = '';
        
        // Nombre de particules dépend de la taille de l'écran
        const particleCount = Math.min(window.innerWidth / 10, 100);
        
        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            
            // Position aléatoire
            const left = Math.random() * 100;
            const size = Math.random() * 2 + 1;
            const duration = Math.random() * 10 + 10;
            const delay = Math.random() * 5;
            
            // Style personnalisé
            particle.style.left = `${left}%`;
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.opacity = Math.random() * 0.5 + 0.1;
            particle.style.animation = `float ${duration}s ${delay}s infinite`;
            particle.style.boxShadow = `0 0 ${Math.random() * 10 + 5}px var(--primary-color)`;
            
            menuParticles.appendChild(particle);
        }
    } catch (error) {
        console.error("Erreur lors de la création des particules:", error);
    }
}

// Chargement des paramètres depuis l'état du jeu
function loadSettings() {
    try {
        // Récupérer les éléments DOM
        const musicToggle = document.getElementById('music-toggle');
        const volumeSlider = document.getElementById('volume-slider');
        const volumeValue = document.getElementById('volume-value');
        const visualizerToggle = document.getElementById('visualizer-toggle');
        const darkThemeToggle = document.getElementById('dark-theme-toggle');
        const particlesToggle = document.getElementById('particles-toggle');
        const notificationsToggle = document.getElementById('notifications-toggle');
        const autosaveToggle = document.getElementById('autosave-toggle');
        
        // S'assurer que les paramètres existent
        if (!game.settings) {
            game.settings = {
                theme: 'dark',
                showAutoSaveNotification: true,
                autoSave: true,
                particleEffects: true,
                audio: {
                    enabled: true,
                    volume: 0.7,
                    visualizer: true
                }
            };
        }
        
        if (!game.settings.audio) {
            game.settings.audio = {
                enabled: true,
                volume: 0.7,
                visualizer: true
            };
        }
        
        // Mettre à jour les contrôles
        if (musicToggle) {
            musicToggle.checked = game.settings.audio.enabled;
        }
        
        if (volumeSlider) {
            volumeSlider.value = (game.settings.audio.volume * 100).toFixed(0);
            
            if (volumeValue) {
                volumeValue.textContent = volumeSlider.value + '%';
            }
        }
        
        if (visualizerToggle) {
            visualizerToggle.checked = game.settings.audio.visualizer;
        }
        
        if (darkThemeToggle) {
            darkThemeToggle.checked = game.settings.theme === 'dark';
        }
        
        if (particlesToggle) {
            particlesToggle.checked = game.settings.particleEffects !== false;
        }
        
        if (notificationsToggle) {
            notificationsToggle.checked = game.settings.showAutoSaveNotification !== false;
        }
        
        if (autosaveToggle) {
            autosaveToggle.checked = game.settings.autoSave !== false;
        }
    } catch (error) {
        console.error("Erreur lors du chargement des paramètres:", error);
    }
}

// Toggle du thème
function applyTheme(theme) {
    try {
        document.body.classList.remove('light-theme', 'dark-theme');
        document.body.classList.add(theme + '-theme');
        
        if (game && game.settings) {
            game.settings.theme = theme;
            saveGame(true);
        }
    } catch (error) {
        console.error("Erreur lors de l'application du thème:", error);
    }
}

// Activer/désactiver les particules
function toggleParticles(enabled) {
    try {
        if (game && game.settings) {
            game.settings.particleEffects = enabled;
            saveGame(true);
        }
        
        // Mettre à jour l'affichage des particules si nécessaire
        // Implémentation selon les besoins spécifiques du jeu
    } catch (error) {
        console.error("Erreur lors du changement des particules:", error);
    }
}

// Activer/désactiver la sauvegarde automatique
function toggleAutoSave(enabled) {
    try {
        if (game && game.settings) {
            game.settings.autoSave = enabled;
            
            // Mettre à jour le système de sauvegarde
            if (enabled) {
                // Démarrer la sauvegarde automatique
                if (!game.saveIntervalId) {
                    game.saveIntervalId = setInterval(function() {
                        saveGame(true);
                    }, 60000); // 1 minute
                }
            } else {
                // Arrêter la sauvegarde automatique
                if (game.saveIntervalId) {
                    clearInterval(game.saveIntervalId);
                    game.saveIntervalId = null;
                }
            }
            
            saveGame(false);
        }
    } catch (error) {
        console.error("Erreur lors du changement de la sauvegarde automatique:", error);
    }
}

// Initialiser le système audio
function initializeAudioSystem() {
    try {
        const bgMusic = document.getElementById('background-music');
        const audioVisualizer = document.getElementById('audio-visualizer');
        
        if (!bgMusic || !audioVisualizer) return;
        
        // Charger les paramètres audio depuis l'état du jeu
        if (game && game.settings && game.settings.audio) {
            // Définir le volume
            bgMusic.volume = game.settings.audio.volume;
            
            // Activer/désactiver selon les paramètres
            if (game.settings.audio.enabled) {
                // Attendre l'interaction utilisateur pour démarrer l'audio (politique des navigateurs)
                document.addEventListener('click', function startAudio() {
                    bgMusic.play().catch(e => console.log("Audio démarrage différé:", e));
                    document.removeEventListener('click', startAudio);
                }, { once: true });
            }
            
            // Afficher/masquer le visualiseur
            audioVisualizer.style.display = game.settings.audio.visualizer ? 'flex' : 'none';
            
            // Initialiser l'analyseur audio si le visualiseur est activé
            if (game.settings.audio.visualizer) {
                initAudioVisualizer();
            }
        }
    } catch (error) {
        console.error("Erreur lors de l'initialisation du système audio:", error);
    }
}

// Activer/désactiver la musique de fond
function toggleBackgroundMusic(enabled) {
    try {
        const bgMusic = document.getElementById('background-music');
        
        if (!bgMusic) return;
        
        if (enabled) {
            bgMusic.play().catch(e => console.log("Erreur lors de la lecture audio:", e));
        } else {
            bgMusic.pause();
        }
        
        // Mettre à jour les paramètres
        if (game && game.settings && game.settings.audio) {
            game.settings.audio.enabled = enabled;
            saveGame(true);
        }
    } catch (error) {
        console.error("Erreur lors du changement de la musique:", error);
    }
}

// Régler le volume de la musique
function setMusicVolume(volume) {
    try {
        const bgMusic = document.getElementById('background-music');
        
        if (!bgMusic) return;
        
        bgMusic.volume = volume;
        
        // Mettre à jour les paramètres
        if (game && game.settings && game.settings.audio) {
            game.settings.audio.volume = volume;
            saveGame(true);
        }
    } catch (error) {
        console.error("Erreur lors du changement de volume:", error);
    }
}

// Activer/désactiver le visualiseur audio
function toggleAudioVisualizer(enabled) {
    try {
        const audioVisualizer = document.getElementById('audio-visualizer');
        
        if (!audioVisualizer) return;
        
        audioVisualizer.style.display = enabled ? 'flex' : 'none';
        
        // Mettre à jour les paramètres
        if (game && game.settings && game.settings.audio) {
            game.settings.audio.visualizer = enabled;
            saveGame(true);
        }
        
        // Initialiser ou arrêter l'analyseur
        if (enabled) {
            initAudioVisualizer();
        } else if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
    } catch (error) {
        console.error("Erreur lors du changement du visualiseur:", error);
    }
}

// Initialisation du visualiseur audio
function initAudioVisualizer() {
    try {
        const bgMusic = document.getElementById('background-music');
        const visualizerBars = document.querySelectorAll('.visualizer-bars .bar');
        
        if (!bgMusic || !visualizerBars.length) return;
        
        // Créer un contexte audio si non existant
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 32;
            
            // Connecter la source audio
            audioSource = audioContext.createMediaElementSource(bgMusic);
            audioSource.connect(analyser);
            analyser.connect(audioContext.destination);
            
            // Créer un tableau pour les données d'analyse
            dataArray = new Uint8Array(analyser.frequencyBinCount);
        }
        
        // Fonction d'animation
        function updateVisualizerBars() {
            if (!game.settings?.audio?.visualizer) {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                return;
            }
            
            // Récupérer les données de fréquence
            analyser.getByteFrequencyData(dataArray);
            
            // Mettre à jour les barres
            visualizerBars.forEach((bar, index) => {
                const i = Math.floor(index / visualizerBars.length * dataArray.length);
                const value = dataArray[i] || 0;
                const height = Math.max(2, (value / 255) * 20);
                
                bar.style.height = `${height}px`;
                
                // Couleur variant avec la fréquence
                const hue = 180 + (value / 255) * 180;
                bar.style.background = `hsl(${hue}, 100%, 70%)`;
            });
            
            // Continuer l'animation
            animationFrameId = requestAnimationFrame(updateVisualizerBars);
        }
        
        // Démarrer l'animation
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }
        animationFrameId = requestAnimationFrame(updateVisualizerBars);
    } catch (error) {
        console.error("Erreur lors de l'initialisation du visualiseur audio:", error);
    }
}

// Démarrer le jeu
function startGame(loadSave) {
    console.log("Démarrage du jeu, charger sauvegarde:", loadSave);
    
    try {
        // Afficher l'écran de chargement
        const loadingOverlay = document.getElementById('loading-overlay');
        const mainMenu = document.getElementById('main-menu');
        
        if (!loadingOverlay || !mainMenu) {
            console.error("Éléments critiques manquants:", {
                loadingOverlay: !!loadingOverlay,
                mainMenu: !!mainMenu
            });
            // Ne pas lever d'erreur, forcer l'affichage du menu si possible
            if (mainMenu) mainMenu.classList.remove('hidden');
            return;
        }
        
        loadingOverlay.classList.remove('hidden');
        mainMenu.classList.add('hidden');
        
        console.log("Transition vers l'écran de chargement effectuée");
        
        // Démarrer le jeu avec un délai pour l'animation de chargement
        setTimeout(() => {
            try {
                console.log("Initialisation après délai...");
                
                // Initialiser le jeu
                init();
                
                console.log("Chargement des données de jeu...");
                
                // Charger la sauvegarde ou démarrer une nouvelle partie
                if (loadSave) {
                    console.log("Chargement de la sauvegarde existante");
                    loadGame();
                } else {
                    console.log("Création d'une nouvelle partie");
                    startNewGame();
                }
                
                console.log("Affichage de l'interface du jeu");
                
                // Afficher le jeu
                const gameContainer = document.querySelector('.game-container');
                if (gameContainer) {
                    gameContainer.style.display = 'block';
                    loadingOverlay.classList.add('hidden');
                    
                    // Démarrer la boucle du jeu
                    console.log("Démarrage de la boucle de jeu");
                    startGameLoop();
                } else {
                    console.error("Conteneur de jeu introuvable");
                    // Forcer le retour au menu même en cas d'erreur
                    loadingOverlay.classList.add('hidden');
                    mainMenu.classList.remove('hidden');
                }
            } catch (innerError) {
                console.error("Erreur dans le processus de démarrage:", innerError);
                
                // S'assurer que les éléments existent et forcer le retour au menu
                if (loadingOverlay) loadingOverlay.classList.add('hidden');
                if (mainMenu) mainMenu.classList.remove('hidden');
            }
        }, 1000);
    } catch (error) {
        console.error("Erreur lors du démarrage du jeu:", error);
        
        // Afficher un message d'erreur et revenir au menu
        alert("Une erreur est survenue lors du démarrage du jeu: " + error.message);
        
        // S'assurer que les éléments existent
        const loadingOverlay = document.getElementById('loading-overlay');
        const mainMenu = document.getElementById('main-menu');
        
        if (loadingOverlay) loadingOverlay.classList.add('hidden');
        if (mainMenu) mainMenu.classList.remove('hidden');
    }
});
            throw new Error("Éléments d'interface manquants");
        }
        
        loadingOverlay.classList.remove('hidden');
        mainMenu.classList.add('hidden');
        
        console.log("Transition vers l'écran de chargement effectuée");
        
        // Démarrer le jeu avec un délai pour l'animation de chargement
        setTimeout(() => {
            try {
                console.log("Initialisation après délai...");
                
                // Initialiser le jeu
                init();
                
                console.log("Chargement des données de jeu...");
                
                // Charger la sauvegarde ou démarrer une nouvelle partie
                if (loadSave) {
                    console.log("Chargement de la sauvegarde existante");
                    loadGame();
                } else {
                    console.log("Création d'une nouvelle partie");
                    startNewGame();
                }
                
                console.log("Affichage de l'interface du jeu");
                
                // Afficher le jeu
                const gameContainer = document.querySelector('.game-container');
                if (gameContainer) {
                    gameContainer.style.display = 'block';
                    loadingOverlay.classList.add('hidden');
                    
                    // Démarrer la boucle du jeu
                    console.log("Démarrage de la boucle de jeu");
                    startGameLoop();
                } else {
                    throw new Error("Conteneur de jeu introuvable");
                }
            } catch (innerError) {
                console.error("Erreur dans le processus de démarrage:", innerError);
                throw innerError; // Relancer pour être capturé par le try/catch externe
            }
        }, 1000);
    } catch (error) {
        console.error("Erreur lors du démarrage du jeu:", error);
        
        // Afficher un message d'erreur et revenir au menu
        alert("Une erreur est survenue lors du démarrage du jeu: " + error.message);
        
        // S'assurer que les éléments existent
        const loadingOverlay = document.getElementById('loading-overlay');
        const mainMenu = document.getElementById('main-menu');
        
        if (loadingOverlay) loadingOverlay.classList.add('hidden');
        if (mainMenu) mainMenu.classList.remove('hidden');
    }
}

// Confirmer la création d'une nouvelle partie
function confirmNewGame() {
    console.log("Confirmation de nouvelle partie, hasSaveData:", hasSaveData);
    
    try {
        if (hasSaveData) {
            if (confirm("Êtes-vous sûr de vouloir créer une nouvelle partie ? Votre progression actuelle sera perdue.")) {
                console.log("Confirmation acceptée, démarrage d'une nouvelle partie");
                startGame(false);
            } else {
                console.log("Création de nouvelle partie annulée par l'utilisateur");
            }
        } else {
            console.log("Pas de sauvegarde existante, démarrage direct d'une nouvelle partie");
            startGame(false);
        }
    } catch (error) {
        console.error("Erreur lors de la confirmation d'une nouvelle partie:", error);
        alert("Une erreur est survenue lors de la création d'une nouvelle partie: " + error.message);
    }
}

// Confirmer la réinitialisation des données
function confirmResetGame() {
    if (confirm("Êtes-vous sûr de vouloir réinitialiser toutes les données du jeu ? Cette action est irréversible.")) {
        (function() { try { return localStorage.removeItem('gh_pages_nanoBotExperienceSave'); } catch(e) { console.error('Erreur localStorage GitHub Pages:', e); return null; } })();
        alert("Toutes les données ont été réinitialisées. Le jeu va redémarrer.");
        location.reload();
    }
}

// Initialisation principale modifiée pour prendre en compte le menu
function init() {
    console.log("Initialisation de Nano Bot Experience v17");
    
    try {
        // Initialiser la structure du jeu
        if (!window.game) {
            console.log("Création de l'objet game");
            window.game = {
                resources: {
                    nanites: 0,
                    energy: 0,
                    matter: 0
                },
                producers: {
                    naniteProducers: 0,
                    energyProducers: 0,
                    matterProducers: 0
                },
                costs: {
                    nanites: 10,
                    energy: 15,
                    matter: 20
                },
                producerCosts: {
                    naniteProducers: 50,
                    energyProducers: 75,
                    matterProducers: 100
                },
                upgrades: {},
                settings: {
                    darkMode: false,
                    accentColorTheme: 'blue',
                    soundEnabled: true,
                    soundVolume: 0.5,
                    particleEffects: true
                },
                stats: {
                    startDate: new Date().toISOString(),
                    lastSaveDate: null,
                    totalClicks: 0,
                    version: "17.0"
                }
            };
        }
        
        // Initialiser les écouteurs d'événements
        setupEventListeners();
        
        // Appliquer les préférences d'affichage
        applyDisplayPreferences();
        
        // Initialiser l'interface utilisateur
        updateUI();
        
        console.log("Initialisation réussie");
        return true;
    } catch (error) {
        console.error("Erreur lors de l'initialisation:", error);
        alert("Une erreur est survenue lors de l'initialisation. Le jeu va redémarrer.");
        
        // Forcer le redémarrage en cas d'erreur critique
        setTimeout(() => {
            window.location.reload();
        }, 1000);
        
        return false;
    }
}
        
        // Initialiser les particules en arrière-plan si la fonction existe
        if (typeof createBackgroundParticles === 'function' && document.querySelector('.game-container')) {
            createBackgroundParticles();
        }
        
        // Supprimer l'ancien écran de chargement s'il existe
        const oldLoadingScreen = document.getElementById('loading-screen');
        if (oldLoadingScreen) {
            oldLoadingScreen.remove();
        }
        
        console.log("Initialisation réussie");
    } catch (error) {
        console.error("Erreur lors de l'initialisation:", error);
    }
}

// Fonction pour afficher une notification de sauvegarde
function showSaveNotification(isAuto = false) {
    try {
        const notification = document.getElementById('save-notification');
        
        if (!notification) return;
        
        // Définir le texte de la notification
        notification.innerHTML = `<i class="fas fa-save"></i> ${isAuto ? 'Sauvegarde automatique' : 'Partie sauvegardée'}`;
        
        // Afficher la notification
        notification.classList.add('show');
        
        // Masquer après 2 secondes
        setTimeout(() => {
            notification.classList.remove('show');
        }, 2000);
    } catch (error) {
        console.error("Erreur lors de l'affichage de la notification:", error);
    }
}

// Démarrer le jeu
// Gestionnaire d'erreurs global
window.onerror = function(message, source, lineno, colno, error) {
    console.error("Erreur JavaScript non interceptée:", { message, source, lineno, colno });
    
    // Afficher un message d'erreur pour l'utilisateur
    const errorMessage = `Une erreur est survenue: ${message} (ligne ${lineno})`;
    
    // Si l'écran de chargement est visible, revenir au menu principal
    const loadingOverlay = document.getElementById('loading-overlay');
    const mainMenu = document.getElementById('main-menu');
    
    if (loadingOverlay && !loadingOverlay.classList.contains('hidden')) {
        loadingOverlay.classList.add('hidden');
        if (mainMenu) mainMenu.classList.remove('hidden');
        
        alert("Erreur lors du chargement du jeu. " + errorMessage);
    }
    
    return true; // Prévenir le comportement par défaut du navigateur
};


// Assurer l'initialisation correcte de l'application
document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM chargé - Démarrage de l'initialisation");
    
    // Initialiser l'application
    try {
        init();
        
        // Afficher le menu principal après l'initialisation
        const loadingOverlay = document.getElementById('loading-overlay');
        const mainMenu = document.getElementById('main-menu');
        
        if (loadingOverlay) loadingOverlay.classList.add('hidden');
        if (mainMenu) mainMenu.classList.remove('hidden');
    } catch (error) {
        console.error("Erreur lors de l'initialisation:", error);
        
        // Forcer l'affichage du menu principal même en cas d'erreur
        const loadingOverlay = document.getElementById('loading-overlay');
        const mainMenu = document.getElementById('main-menu');
        
        if (loadingOverlay) loadingOverlay.classList.add('hidden');
        if (mainMenu) mainMenu.classList.remove('hidden');
    }
});
    
// Mécanisme de sécurité pour éviter un chargement infini
window.addEventListener('load', function() {
    console.log("Page chargée - Démarrage du mécanisme de sécurité");
    
    // Forcer la fin du chargement après 5 secondes si l'écran de chargement est toujours visible
    setTimeout(function() {
        const loadingOverlay = document.getElementById('loading-overlay');
        const mainMenu = document.getElementById('main-menu');
        
        if (loadingOverlay && window.getComputedStyle(loadingOverlay).display !== 'none') {
            console.log("Mécanisme de sécurité activé: l'écran de chargement est resté bloqué");
            loadingOverlay.classList.add('hidden');
            
            if (mainMenu) {
                mainMenu.classList.remove('hidden');
                console.log("Menu principal affiché par le mécanisme de sécurité");
            }
        }
    }, 5000);
});


// FILET DE SÉCURITÉ ULTIME V17
window.addEventListener('load', function() {
    console.log("V17: Activation du filet de sécurité final");
    
    // Vérifier l'interface après 5 secondes
    setTimeout(function() {
        const loadingOverlay = document.getElementById('loading-overlay');
        const mainMenu = document.getElementById('main-menu');
        const gameContainer = document.querySelector('.game-container');
        
        // Forcer l'affichage d'une interface si rien n'est visible
        let interfaceVisible = false;
        
        if (mainMenu && window.getComputedStyle(mainMenu).display !== 'none' && !mainMenu.classList.contains('hidden')) {
            interfaceVisible = true;
            console.log("V17: Menu principal visible");
        }
        
        if (gameContainer && window.getComputedStyle(gameContainer).display !== 'none' && !gameContainer.classList.contains('hidden')) {
            interfaceVisible = true;
            console.log("V17: Interface de jeu visible");
        }
        
        if (!interfaceVisible) {
            console.log("V17: ALERTE - Aucune interface visible après 5 secondes");
            
            // Cacher l'écran de chargement
            if (loadingOverlay) {
                loadingOverlay.classList.add('hidden');
                console.log("V17: Écran de chargement forcé caché");
            }
            
            // Afficher le menu principal par défaut
            if (mainMenu) {
                mainMenu.classList.remove('hidden');
                console.log("V17: Menu principal forcé visible");
            }
        }
    }, 5000);
}, false);

// Gestionnaire d'erreurs spécifique à GitHub Pages
window.addEventListener('error', function(event) {
    console.error("Erreur GitHub Pages:", event.message, "à", event.filename, "ligne", event.lineno);
    
    // Vérifier si l'erreur est liée à une ressource externe
    if (event.filename && event.filename.includes("githubusercontent.com")) {
        console.warn("Erreur de ressource GitHub détectée, tentative de récupération...");
        
        // Forcer le redémarrage de l'interface si nécessaire
        const loadingOverlay = document.getElementById('loading-overlay');
        const mainMenu = document.getElementById('main-menu');
        
        if (loadingOverlay && !loadingOverlay.classList.contains('hidden')) {
            console.log("GitHub Pages: Forçage du retour au menu principal suite à une erreur de ressource");
            loadingOverlay.classList.add('hidden');
            
            if (mainMenu) {
                mainMenu.classList.remove('hidden');
            }
        }
    }
}, false);

// Récupération des données de sauvegarde GitHub Pages au démarrage
document.addEventListener('DOMContentLoaded', function() {
    // Vérifier et migrer les anciennes sauvegardes si nécessaires
    try {
        const oldSave = (function() { try { return localStorage.getItem('nanoBotExperienceSave'); } catch(e) { console.error('Erreur localStorage GitHub Pages:', e); return null; } })();
        if (oldSave && !(function() { try { return localStorage.getItem('gh_pages_nanoBotExperienceSave'); } catch(e) { console.error('Erreur localStorage GitHub Pages:', e); return null; } })()) {
            console.log("Migration de sauvegarde détectée pour GitHub Pages");
            (function() { try { return localStorage.setItem('gh_pages_nanoBotExperienceSave', oldSave); } catch(e) { console.error('Erreur localStorage GitHub Pages:', e); return null; } })();
            // Ne pas supprimer l'ancienne sauvegarde pour compatibilité
        }
    } catch (error) {
        console.error("Erreur lors de la migration de sauvegarde:", error);
    }
});
</script>

        <div id="github-pages-notice" style="display:none; position:fixed; bottom:10px; right:10px; background:rgba(0,0,0,0.8); color:white; padding:10px; border-radius:5px; z-index:9999; font-size:12px;">
            <p>Déployé sur GitHub Pages</p>
            <p>Si vous rencontrez des problèmes, <a href="https://github.com/juliuss34/nanobot-experience/issues" style="color:#4CAF50;">signalez-les ici</a></p>
            <button onclick="this.parentNode.style.display='none'" style="background:#333; color:white; border:none; padding:3px 8px; margin-top:5px; cursor:pointer;">OK</button>
        </div>
        <script>
            // Afficher le message GitHub Pages après 5 secondes
            setTimeout(function() {
                const notice = document.getElementById('github-pages-notice');
                if (notice) notice.style.display = 'block';
            }, 5000);
        </script>
</body>
</html>
