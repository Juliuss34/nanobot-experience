<!DOCTYPE html>
<!--
Version 9 - Correction des problèmes d'achat de producteurs:
- Ajout de logs de débogage détaillés dans les fonctions liées aux producteurs
- Conversion explicite des types numériques (Number(), parseFloat(), parseInt())
- Amélioration de getProducerCost() avec validations supplémentaires
- Renforcement de updateProducers() avec vérifications de types et de structures
- Amélioration de buyProducer() avec gestion d'erreurs et conversions de types
- Affichage de notifications pour indiquer les succès ou échecs d'achat
- Protection contre les erreurs de comparaison de types différents

Version 8 - Résolution des erreurs TypeError et initialisation robuste:
- Correction de getDefaultGameState() pour retourner correctement l'objet defaultState
- Refonte complète de sanitizeGameState() pour une fusion profonde et sécurisée
- Amélioration de loadGame() pour utiliser la nouvelle fonction sanitizeGameState
- Protection contre les références undefined dans game.producers.find() et game.expansion
- Vérifications robustes de la structure du jeu avant manipulation
- Ajout d'une fonction initializeElements() pour garantir la disponibilité des éléments DOM
- Amélioration de startNewGame() avec gestion d'erreurs et récupération d'urgence
- Renforcement de proceedToGame() avec vérifications des structures essentielles
- Révision complète de init() pour garantir une initialisation correcte

Version 7 - Renforcement de la robustesse et élimination des NaN:
- Protection contre les NaN dans toutes les fonctions de calcul principales
- Amélioration de la gestion des sauvegardes/chargements corrompus
- Fusion plus sécurisée des données lors du chargement
- Renforcement de toutes les conditions d'évaluation 
- Amélioration de la gestion des erreurs dans les effets de jalons et succès
- Prévention des valeurs négatives ou NaN dans les multiplicateurs et valeurs de base
- Mise en place de limites sur les valeurs pour éviter les débordements
- Mise à jour de la boucle de jeu principale pour plus de stabilité
- Amélioration de la fonction applyTheme avec des vérifications supplémentaires

Version 6 - Corrections des bugs d'améliorations:
- Harmonisation des définitions des producteurs entre game et getDefaultGameState()
- Renforcement des conditions des améliorations pour éviter les erreurs de référence
- Ajout de recherche de producteurs par ID au lieu de se fier aux indices
- Ajout de gestion d'erreurs robuste pour les fonctions requirement et effect
- Amélioration des logs de diagnostic pour le débogage
- Vérifications supplémentaires dans les fonctions d'achat d'améliorations
- Protection contre les fonctions manquantes avec des fallbacks
- Vérification plus robuste des références potentiellement nulles/undefined
-->
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nano Bot Experience v9</title>
    <style>
/* Style amélioré pour Nano Bot Experience */
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Roboto:wght@300;400;500&display=swap');

:root {
    /* Thème sombre (par défaut) */
    --primary-color: #00d2ff;
    --primary-glow: rgba(0, 210, 255, 0.5);
    --accent-color: #64ffda;
    --accent-glow: rgba(100, 255, 218, 0.5);
    --bg-dark: #0a0d14;
    --bg-panel: rgba(15, 25, 40, 0.9);
    --text-light: #e0e0e0;
    --text-bright: #ffffff;
    --gradient-blue: linear-gradient(135deg, #0277bd, #00c9ff);
    --gradient-green: linear-gradient(135deg, #00897b, #00ffd5);
    --gradient-purple: linear-gradient(135deg, #6a1b9a, #a84fff);
    --border-glow: 0 0 20px var(--primary-glow);
    --shadow-soft: 0 5px 15px rgba(0, 0, 0, 0.3);
    --producer-bg: rgba(20, 40, 60, 0.8);
    --producer-border: rgba(0, 210, 255, 0.15);
    --producer-hover-bg: rgba(30, 50, 70, 0.8);
    --producer-hover-border: rgba(0, 210, 255, 0.3);
    --section-bg: rgba(15, 30, 50, 0.7);
    --milestone-bg: rgba(20, 40, 60, 0.8);
    --milestone-unlocked-bg: rgba(0, 100, 100, 0.2);
    --description-text: #b0bec5;
    --footer-text: #b0bec5;
    --stars-opacity: 0.1;
    --grid-color: rgba(0, 210, 255, 0.05);
}

/* Thème clair */
:root.light-theme {
    --primary-color: #0077cc;
    --primary-glow: rgba(0, 119, 204, 0.3);
    --accent-color: #00aa88;
    --accent-glow: rgba(0, 170, 136, 0.3);
    --bg-dark: #f5f8fa;
    --bg-panel: rgba(255, 255, 255, 0.9);
    --text-light: #333333;
    --text-bright: #000000;
    --gradient-blue: linear-gradient(135deg, #0088cc, #00aaff);
    --gradient-green: linear-gradient(135deg, #00aa88, #33ccaa);
    --gradient-purple: linear-gradient(135deg, #7722aa, #aa66ff);
    --border-glow: 0 0 20px rgba(0, 119, 204, 0.3);
    --shadow-soft: 0 5px 15px rgba(0, 0, 0, 0.1);
    --producer-bg: rgba(240, 245, 250, 0.9);
    --producer-border: rgba(0, 119, 204, 0.2);
    --producer-hover-bg: rgba(230, 240, 250, 0.9);
    --producer-hover-border: rgba(0, 119, 204, 0.4);
    --section-bg: rgba(245, 250, 255, 0.95);
    --milestone-bg: rgba(240, 245, 250, 0.9);
    --milestone-unlocked-bg: rgba(230, 255, 245, 0.7);
    --description-text: #4a5568;
    --footer-text: #4a5568;
    --stars-opacity: 0.03;
    --grid-color: rgba(0, 119, 204, 0.05);
}

/* Animations globales */
@keyframes pulse {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.05); opacity: 0.9; }
    100% { transform: scale(1); opacity: 1; }
}

@keyframes glow {
    0% { box-shadow: 0 0 5px var(--primary-glow); }
    50% { box-shadow: 0 0 20px var(--primary-glow); }
    100% { box-shadow: 0 0 5px var(--primary-glow); }
}

@keyframes float {
    0% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
    100% { transform: translateY(0); }
}

@keyframes bg-drift {
    0% { background-position: 0% 0%; }
    100% { background-position: 100% 100%; }
}

/* Base */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    transition: all 0.3s ease;
}

body {
    font-family: 'Roboto', sans-serif;
    background-color: var(--bg-dark);
    color: var(--text-light);
    line-height: 1.6;
    overflow-x: hidden;
    background-image: 
        radial-gradient(circle at 25% 25%, rgba(0, 100, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 75% 75%, rgba(0, 255, 200, 0.1) 0%, transparent 50%),
        linear-gradient(to right, rgba(0, 30, 60, 0.2), rgba(10, 13, 20, 0.2));
    background-size: 200% 200%;
    animation: bg-drift 20s linear infinite alternate;
    position: relative;
}

/* Étoiles en arrière-plan */
body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: radial-gradient(var(--text-bright) 1px, transparent 1px);
    background-size: 50px 50px;
    opacity: var(--stars-opacity);
    z-index: -1;
    pointer-events: none;
}

.game-container {
    max-width: 1100px;
    margin: 20px auto;
    padding: 25px;
    background-color: var(--bg-panel);
    box-shadow: var(--border-glow);
    border-radius: 16px;
    min-height: calc(100vh - 40px);
    display: flex;
    flex-direction: column;
    gap: 20px;
    border: 1px solid rgba(0, 210, 255, 0.2);
    position: relative;
    overflow: hidden;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

/* Effet de grille de fond */
.game-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: 
        linear-gradient(to right, var(--grid-color) 1px, transparent 1px),
        linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px);
    background-size: 20px 20px;
    z-index: -1;
    pointer-events: none;
}

/* En-tête */
header {
    text-align: center;
    margin-bottom: 30px;
    padding-bottom: 20px;
    border-bottom: 1px solid rgba(0, 210, 255, 0.3);
    position: relative;
}

header::after {
    content: '';
    position: absolute;
    bottom: -1px;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    height: 3px;
    background: var(--gradient-blue);
    border-radius: 3px;
}

h1 {
    font-family: 'Orbitron', sans-serif;
    color: var(--primary-color);
    margin-bottom: 8px;
    font-size: 3rem;
    text-shadow: 0 0 15px var(--primary-glow);
    letter-spacing: 2px;
    animation: pulse 5s infinite ease-in-out;
}

.subtitle {
    color: var(--accent-color);
    font-style: italic;
    margin-bottom: 25px;
    font-size: 1.1rem;
    opacity: 0.8;
}

/* Statistiques */
.stats {
    display: flex;
    justify-content: center;
    gap: 25px;
    font-size: 18px;
    flex-wrap: wrap;
    margin-top: 15px;
}

.stat {
    padding: 10px 18px;
    background-color: rgba(0, 100, 255, 0.1);
    border-radius: 10px;
    border: 1px solid rgba(0, 210, 255, 0.2);
    display: flex;
    align-items: center;
    gap: 10px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    position: relative;
    overflow: hidden;
}

.stat::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
    transition: 0.5s;
}

.stat:hover::before {
    left: 100%;
}

.stat.primary {
    background-color: rgba(0, 100, 255, 0.2);
    border: 1px solid rgba(0, 210, 255, 0.3);
    animation: glow 3s infinite alternate;
    box-shadow: 0 0 15px rgba(0, 210, 255, 0.3);
}

.stat i {
    color: var(--primary-color);
    font-size: 1.2em;
}

.stat span {
    font-weight: bold;
    color: var(--accent-color);
    text-shadow: 0 0 5px rgba(100, 255, 218, 0.5);
}

/* Section principale */
main {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 30px;
}

/* Section clicker */
.clicker-section {
    text-align: center;
    margin-bottom: 20px;
    position: relative;
}

#clicker {
    padding: 22px 45px;
    font-size: 22px;
    font-family: 'Orbitron', sans-serif;
    font-weight: 500;
    background: var(--gradient-blue);
    color: white;
    border: none;
    border-radius: 50px;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 5px 20px rgba(0, 188, 212, 0.4), 0 0 30px rgba(0, 150, 255, 0.2);
    position: relative;
    overflow: hidden;
    letter-spacing: 1px;
    text-transform: uppercase;
}

#clicker:hover {
    transform: translateY(-5px) scale(1.05);
    box-shadow: 0 8px 25px rgba(0, 188, 212, 0.5), 0 0 40px rgba(0, 150, 255, 0.3);
}

#clicker:active {
    transform: translateY(2px) scale(0.95);
    box-shadow: 0 2px 10px rgba(0, 188, 212, 0.3);
}

#clicker::before {
    content: "";
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: rgba(255, 255, 255, 0.1);
    transform: rotate(45deg);
    pointer-events: none;
    transition: all 0.5s;
    opacity: 0;
}

#clicker:hover::before {
    opacity: 1;
    transform: rotate(45deg) translateY(-20%);
}

.click-value {
    margin-top: 12px;
    font-size: 16px;
    color: var(--primary-color);
    text-shadow: 0 0 5px rgba(0, 210, 255, 0.3);
    animation: float 3s ease-in-out infinite;
}

/* Barre de progression */
.progress-container {
    margin: 15px 0 25px;
    padding: 0 30px;
}

.progress-bar {
    height: 24px;
    background-color: rgba(0, 100, 200, 0.2);
    border-radius: 12px;
    overflow: hidden;
    border: 1px solid rgba(0, 210, 255, 0.3);
    box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
    position: relative;
}

.progress-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #0288d1, #00e5ff);
    transition: width 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
    position: relative;
    overflow: hidden;
}

.progress-fill::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    animation: progress-shine 3s linear infinite;
}

@keyframes progress-shine {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

.progress-text {
    text-align: center;
    margin-top: 8px;
    font-size: 15px;
    color: var(--primary-color);
    text-shadow: 0 0 5px rgba(0, 210, 255, 0.2);
}

/* Sections de contenu */
.sections-container {
    display: flex;
    gap: 25px;
    margin-bottom: 30px;
}

section {
    flex: 1;
    background-color: var(--section-bg);
    padding: 18px;
    border-radius: 12px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(0, 210, 255, 0.2);
    transition: transform 0.3s, box-shadow 0.3s;
    position: relative;
    overflow: hidden;
}

section:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25), 0 0 15px rgba(0, 150, 255, 0.2);
}

section h2 {
    font-family: 'Orbitron', sans-serif;
    border-bottom: 1px solid rgba(0, 210, 255, 0.3);
    padding-bottom: 12px;
    margin-bottom: 18px;
    color: var(--primary-color);
    font-size: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
    text-shadow: 0 0 5px rgba(0, 210, 255, 0.3);
}

section h2 i {
    color: var(--accent-color);
    font-size: 1.1em;
}

.producer-item, .upgrade-item {
    background-color: var(--producer-bg);
    padding: 15px;
    margin-bottom: 15px;
    border-radius: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
    border: 1px solid var(--producer-border);
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
}

.producer-item:hover, .upgrade-item:hover {
    background-color: var(--producer-hover-bg);
    border-color: var(--producer-hover-border);
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.25);
}

.producer-item::after, .upgrade-item::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
    transform: scaleX(0);
    transition: transform 0.4s;
}

.producer-item:hover::after, .upgrade-item:hover::after {
    transform: scaleX(1);
}

.producer-info, .upgrade-info {
    flex: 1;
}

.producer-title, .upgrade-title {
    font-weight: bold;
    color: var(--primary-color);
    font-family: 'Orbitron', sans-serif;
    font-size: 1.05rem;
    display: flex;
    align-items: center;
    gap: 8px;
}

.producer-stats, .upgrade-desc {
    font-size: 14px;
    color: var(--description-text);
    margin-top: 8px;
    line-height: 1.4;
}

.producer-stats small {
    display: block;
    margin-top: 5px;
    opacity: 0.8;
    font-size: 12px;
    font-style: italic;
}

.buy-button {
    padding: 10px 18px;
    background: var(--gradient-green);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 3px 10px rgba(0, 150, 136, 0.3);
    font-family: 'Orbitron', sans-serif;
    font-size: 0.9rem;
    letter-spacing: 0.5px;
    display: flex;
    align-items: center;
    gap: 8px;
    position: relative;
    overflow: hidden;
}

.buy-button:hover:not(:disabled) {
    background: linear-gradient(45deg, #00796b, #00bfa5);
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(0, 150, 136, 0.4);
}

.buy-button:active:not(:disabled) {
    transform: translateY(1px);
    box-shadow: 0 2px 5px rgba(0, 150, 136, 0.3);
}

.buy-button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: 0.5s;
}

.buy-button:hover:not(:disabled)::before {
    left: 100%;
}

.buy-button:disabled {
    background: linear-gradient(45deg, #455a64, #607d8b);
    cursor: not-allowed;
    opacity: 0.7;
    box-shadow: none;
}

/* Grille de jalons */
.milestones-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 20px;
    margin-top: 15px;
}

.milestone-item {
    background-color: var(--milestone-bg);
    padding: 20px 15px;
    border-radius: 10px;
    text-align: center;
    border: 1px solid var(--producer-border);
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
}

.milestone-item:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
}

.milestone-item.unlocked {
    background-color: var(--milestone-unlocked-bg);
    border-color: rgba(0, 255, 200, 0.3);
    box-shadow: 0 0 20px rgba(0, 255, 200, 0.2);
}

.milestone-item.next {
    border-color: rgba(0, 210, 255, 0.5);
    box-shadow: 0 0 20px rgba(0, 150, 255, 0.3);
    animation: pulse-milestone 2s infinite alternate;
}

@keyframes pulse-milestone {
    0% { box-shadow: 0 0 10px rgba(0, 150, 255, 0.2); }
    100% { box-shadow: 0 0 20px rgba(0, 150, 255, 0.4); }
}

.milestone-icon {
    font-size: 30px;
    color: var(--primary-color);
    margin-bottom: 10px;
    transition: transform 0.3s;
}

.milestone-item:hover .milestone-icon {
    transform: scale(1.2);
}

.milestone-item.unlocked .milestone-icon {
    color: var(--accent-color);
    text-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
}

.milestone-name {
    font-weight: bold;
    font-family: 'Orbitron', sans-serif;
    color: var(--primary-color);
    margin-bottom: 5px;
    font-size: 1rem;
}

.milestone-item.unlocked .milestone-name {
    color: var(--accent-color);
}

.milestone-desc {
    font-size: 13px;
    color: var(--description-text);
    line-height: 1.3;
}

.milestone-req {
    font-size: 12px;
    color: #7f8c8d;
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(0, 210, 255, 0.15);
    width: 100%;
}

/* Section achievements */
.achievements-section {
    margin-top: 25px;
}

.achievements-section h2 {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.achievements-bonus {
    font-size: 0.85em;
    background-color: rgba(100, 255, 218, 0.15);
    padding: 5px 10px;
    border-radius: 20px;
    color: var(--accent-color);
}

.achievements-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 15px;
    margin-top: 15px;
}

.achievement-item {
    background-color: var(--milestone-bg);
    padding: 15px;
    border-radius: 10px;
    text-align: center;
    border: 1px solid var(--producer-border);
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.achievement-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(45deg, transparent, rgba(100, 255, 218, 0.03), transparent);
    z-index: -1;
}

/* Style pour les succès verrouillés */
.achievement-item.locked {
    filter: grayscale(1);
    opacity: 0.7;
}

.achievement-item.locked .achievement-icon i {
    color: var(--description-text);
}

.achievement-item.locked .achievement-name {
    color: var(--description-text);
}

/* Style pour les succès débloqués */
.achievement-item.unlocked {
    background-color: var(--milestone-unlocked-bg);
    border-color: rgba(100, 255, 218, 0.3);
    box-shadow: 0 0 15px rgba(100, 255, 218, 0.15);
}

.achievement-item.unlocked::before {
    background: linear-gradient(45deg, transparent, rgba(100, 255, 218, 0.1), transparent);
}

.achievement-icon {
    height: 40px;
    width: 40px;
    background-color: rgba(100, 255, 218, 0.1);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 5px;
}

.achievement-icon i {
    font-size: 20px;
    color: var(--accent-color);
}

.achievement-name {
    font-weight: bold;
    font-family: 'Orbitron', sans-serif;
    color: var(--primary-color);
    margin-bottom: 5px;
    font-size: 0.95rem;
}

.achievement-desc {
    font-size: 13px;
    color: var(--description-text);
    line-height: 1.3;
    flex-grow: 1;
}

.achievement-reward {
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(0, 210, 255, 0.15);
    font-size: 12px;
    color: var(--accent-color);
    width: 100%;
}

/* Section prestige */
.prestige-section {
    text-align: center;
    padding: 25px;
    background-color: rgba(15, 35, 55, 0.7);
    border-radius: 12px;
    margin-top: 25px;
    border: 1px solid rgba(156, 39, 176, 0.3);
    box-shadow: 0 0 25px rgba(156, 39, 176, 0.15);
    position: relative;
    overflow: hidden;
}

.prestige-section::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at center, rgba(156, 39, 176, 0.1) 0%, transparent 70%);
    z-index: -1;
}

.prestige-section h2 {
    font-family: 'Orbitron', sans-serif;
    color: #ce93d8;
    margin-bottom: 15px;
    font-size: 1.5rem;
    text-shadow: 0 0 10px rgba(156, 39, 176, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
}

.prestige-section h2 i {
    color: #e1bee7;
}

.prestige-section p {
    margin-bottom: 12px;
    color: #e0e0e0;
}

.prestige-section p span {
    font-weight: bold;
    color: #ce93d8;
    text-shadow: 0 0 5px rgba(156, 39, 176, 0.5);
}

#prestige-button {
    margin-top: 20px;
    padding: 15px 30px;
    background: var(--gradient-purple);
    color: white;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 5px 15px rgba(156, 39, 176, 0.3);
    font-family: 'Orbitron', sans-serif;
    font-size: 1rem;
    letter-spacing: 1px;
    position: relative;
    overflow: hidden;
}

#prestige-button:hover:not([disabled]) {
    background: linear-gradient(45deg, #6a1b9a, #9c27b0);
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(156, 39, 176, 0.4), 0 0 30px rgba(156, 39, 176, 0.3);
}

#prestige-button:active:not([disabled]) {
    transform: translateY(0);
    box-shadow: 0 3px 10px rgba(156, 39, 176, 0.3);
}

#prestige-button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: 0.5s;
}

#prestige-button:hover:not([disabled])::before {
    left: 100%;
}

#prestige-button:disabled {
    background: linear-gradient(45deg, #455a64, #607d8b);
    box-shadow: none;
    cursor: not-allowed;
    opacity: 0.7;
}

/* Pied de page */
footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 35px;
    padding-top: 20px;
    border-top: 1px solid rgba(0, 210, 255, 0.3);
    position: relative;
}

.footer-buttons {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

footer::before {
    content: '';
    position: absolute;
    top: -1px;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    height: 3px;
    background: var(--gradient-blue);
    border-radius: 3px;
}

footer button {
    padding: 12px 20px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    gap: 8px;
    font-family: 'Orbitron', sans-serif;
    font-size: 0.9rem;
    letter-spacing: 0.5px;
    position: relative;
    overflow: hidden;
}

#save-button {
    background: var(--gradient-blue);
    color: white;
    box-shadow: 0 3px 10px rgba(2, 136, 209, 0.3);
}

#save-button:hover {
    background: linear-gradient(45deg, #0277bd, #039be5);
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(2, 136, 209, 0.4);
}

#reset-button {
    background: linear-gradient(45deg, #d32f2f, #f44336);
    color: white;
    box-shadow: 0 3px 10px rgba(211, 47, 47, 0.3);
}

#reset-button:hover {
    background: linear-gradient(45deg, #c62828, #e53935);
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(211, 47, 47, 0.4);
}

#theme-toggle {
    background: linear-gradient(45deg, #424242, #757575);
    color: white;
    box-shadow: 0 3px 10px rgba(66, 66, 66, 0.3);
}

#theme-toggle:hover {
    background: linear-gradient(45deg, #303030, #616161);
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(66, 66, 66, 0.4);
}

/* Style lorsque le thème clair est actif */
:root.light-theme #theme-toggle {
    background: linear-gradient(45deg, #ffb300, #ffd54f);
    color: #333;
}

:root.light-theme #theme-toggle:hover {
    background: linear-gradient(45deg, #ffa000, #ffca28);
}

footer button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: 0.5s;
}

footer button:hover::before {
    left: 100%;
}

.info {
    font-size: 14px;
    color: var(--footer-text);
}

/* Animation pour les gains de ressources */
@keyframes nanobot-gain {
    0% {
        transform: scale(1);
        color: var(--accent-color);
    }
    50% {
        transform: scale(1.6);
        color: var(--primary-color);
        text-shadow: 0 0 20px var(--primary-glow), 0 0 40px var(--primary-glow);
    }
    100% {
        transform: scale(1);
        color: var(--accent-color);
    }
}

.nanobot-gain {
    animation: nanobot-gain 0.8s cubic-bezier(0.19, 1, 0.22, 1);
}

/* Nanobots flottants améliorés */
.floating-nanobot {
    position: absolute;
    background-color: var(--primary-color);
    border-radius: 50%;
    width: 4px;
    height: 4px;
    pointer-events: none;
    box-shadow: 0 0 10px var(--primary-glow);
    z-index: 1000;
    opacity: 0;
    animation: float-up 4s cubic-bezier(0.23, 1, 0.32, 1) forwards;
}

@keyframes float-up {
    0% {
        transform: translateY(0) rotate(0deg) scale(0.8);
        opacity: 0.8;
    }
    50% {
        opacity: 1;
        transform: translateY(-50px) rotate(180deg) scale(1.2);
    }
    100% {
        transform: translateY(-150px) rotate(360deg) scale(0.5);
        opacity: 0;
    }
}

/* Notifications améliorées */
.notification {
    position: fixed;
    bottom: -100px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, rgba(0, 150, 255, 0.9), rgba(0, 100, 255, 0.9));
    color: white;
    padding: 15px 25px;
    border-radius: 12px;
    z-index: 1000;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3), 0 0 20px rgba(0, 150, 255, 0.5);
    transition: bottom 0.5s cubic-bezier(0.19, 1, 0.22, 1);
    font-weight: bold;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    font-family: 'Orbitron', sans-serif;
    letter-spacing: 0.5px;
}

.notification::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    animation: notification-shine 2s linear infinite;
    border-radius: 12px;
}

@keyframes notification-shine {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

.notification.show {
    bottom: 30px;
}

/* Style pour la notification de succès */
.notification.success {
    background: linear-gradient(135deg, rgba(100, 255, 218, 0.9), rgba(0, 200, 170, 0.9));
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3), 0 0 20px rgba(100, 255, 218, 0.5);
}

/* Message de sauvegarde automatique */
.autosave-notification {
    position: fixed;
    top: 10px;
    right: -200px;
    background: rgba(0, 150, 255, 0.7);
    color: white;
    padding: 8px 15px;
    border-radius: 6px;
    z-index: 1000;
    font-size: 13px;
    font-family: 'Orbitron', sans-serif;
    transition: right 0.3s ease-in-out;
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
    opacity: 0.9;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.autosave-notification.show {
    right: 10px;
}

/* Styles de l'écran de chargement */
#loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--bg-dark);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    transition: opacity 0.5s ease-out;
}

#loading-screen.hidden {
    opacity: 0;
    pointer-events: none;
}

#loading-screen p {
    margin-top: 20px;
    color: var(--primary-color);
    font-family: 'Orbitron', sans-serif;
    font-size: 1.2rem;
    text-align: center;
}

.spinner {
    width: 60px;
    height: 60px;
    border: 5px solid rgba(0, 210, 255, 0.1);
    border-top-color: var(--primary-color);
    border-radius: 50%;
    animation: spin 1s ease-in-out infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Styles pour les options de démarrage */
#start-options {
    display: none;
    flex-direction: column;
    align-items: center;
    margin-top: 30px;
    gap: 15px;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.4s ease-out, transform 0.4s ease-out;
}

#start-options.show {
    opacity: 1;
    transform: translateY(0);
}

.start-button {
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    color: var(--text-light);
    border: none;
    border-radius: 25px;
    padding: 12px 30px;
    font-family: 'Orbitron', sans-serif;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    min-width: 200px;
    text-align: center;
}

.start-button:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
}

.start-button:active {
    transform: translateY(1px);
}

#continue-button {
    background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
}

#new-game-button {
    background: linear-gradient(135deg, #ff5722, #f44336);
}

#new-game-button.warning {
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(255, 87, 34, 0.7); }
    70% { box-shadow: 0 0 0 15px rgba(255, 87, 34, 0); }
    100% { box-shadow: 0 0 0 0 rgba(255, 87, 34, 0); }
}

/* Media queries pour la responsivité */
@media (max-width: 768px) {
    .sections-container {
        flex-direction: column;
    }
    
    .stats {
        flex-direction: column;
        align-items: center;
        gap: 15px;
    }
    
    #clicker {
        padding: 18px 35px;
        font-size: 18px;
    }
    
    .milestones-grid {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    }
    
    h1 {
        font-size: 2.5rem;
    }
    
    footer {
        flex-direction: column;
        gap: 15px;
    }
    
    .info {
        margin-top: 10px;
    }
}
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <!-- Écran de chargement -->
    <div id="loading-screen">
        <div class="spinner"></div>
        <p id="loading-text">Chargement de Nano Bot Experience...</p>
        <div id="start-options" style="display: none;">
            <button id="continue-button" class="start-button">Continuer la Partie</button>
            <button id="new-game-button" class="start-button">Nouvelle Partie</button>
        </div>
    </div>
    
    <!-- Conteneur principal -->
    <div class="game-container" style="display: none;">
        <header>
            <h1>Nano Bot Experience</h1>
            <div class="subtitle">Conquérir l'univers à l'échelle nanométrique</div>
            
            <div class="stats">
                <div class="stat primary">
                    <i class="fas fa-microchip"></i>
                    <span id="nanobots">0</span> nanobots
                </div>
                <div class="stat">
                    <i class="fas fa-bolt"></i>
                    <span id="per-second">0.0</span> par seconde
                </div>
                <div class="stat">
                    <i class="fas fa-globe"></i>
                    Expansion: <span id="expansion-level">Terre</span>
                </div>
            </div>
        </header>

        <main>
            <div class="clicker-section">
                <button id="clicker">Répliquer</button>
                <div class="click-value">+<span id="click-value">1</span> nanobots par clic</div>
            </div>

            <div class="progress-container">
                <div class="progress-bar">
                    <div id="expansion-progress" class="progress-fill"></div>
                </div>
                <div class="progress-text">Progression vers la prochaine zone: <span id="expansion-percent">0</span>%</div>
            </div>

            <div class="sections-container">
                <section class="producers">
                    <h2><i class="fas fa-industry"></i> Fabrication</h2>
                    <div id="producers-container"></div>
                </section>

                <section class="upgrades">
                    <h2><i class="fas fa-flask"></i> Recherche</h2>
                    <div id="upgrades-container"></div>
                </section>
            </div>

            <section class="expansion-milestones">
                <h2><i class="fas fa-rocket"></i> Expansion</h2>
                <div id="milestones-container" class="milestones-grid"></div>
            </section>

            <section class="prestige-section" id="prestige-section">
                <h2><i class="fas fa-dna"></i> Évolution Nanobotique</h2>
                <p>Niveau d'évolution actuel: <span id="prestige-points">0</span></p>
                <p>Multiplicateur actuel: <span id="prestige-multiplier">x1.0</span></p>
                <p>Évolution potentielle: <span id="prestige-to-gain">0</span> niveau(x)</p>
                <button id="prestige-button" disabled>Évoluer vers la prochaine génération</button>
            </section>
            
            <section class="achievements-section">
                <h2><i class="fas fa-trophy"></i> Succès <span class="achievements-bonus">+<span id="achievements-bonus">0</span>% de production</span></h2>
                <div id="achievements-container" class="achievements-grid"></div>
            </section>
        </main>

        <footer>
            <div class="footer-buttons">
                <button id="save-button"><i class="fas fa-save"></i> Sauvegarder</button>
                <button id="reset-button"><i class="fas fa-trash"></i> Réinitialiser</button>
                <button id="theme-toggle"><i class="fas fa-moon"></i> <span>Thème</span></button>
            </div>
            <div class="info">
                Dernière sauvegarde: <span id="last-save">Jamais</span>
            </div>
        </footer>
    </div>

    <!-- Ajout du script pour les particules en arrière-plan -->
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Création aléatoire de particules en arrière-plan
        function createBackgroundParticles() {
            const container = document.querySelector('.game-container');
            const particleCount = 15;
            
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'floating-nanobot';
                
                // Positions aléatoires
                const x = Math.random() * 100;
                const y = Math.random() * 100;
                const delay = Math.random() * 10;
                const duration = 5 + Math.random() * 10;
                const size = 2 + Math.random() * 3;
                
                particle.style.left = `${x}%`;
                particle.style.top = `${y}%`;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.opacity = '0.3';
                particle.style.animationDelay = `${delay}s`;
                particle.style.animationDuration = `${duration}s`;
                
                container.appendChild(particle);
                
                // Supprimer et recréer la particule après son animation
                setTimeout(() => {
                    particle.remove();
                    createParticle();
                }, duration * 1000 + delay * 1000);
            }
        }
        
        function createParticle() {
            const container = document.querySelector('.game-container');
            const particle = document.createElement('div');
            particle.className = 'floating-nanobot';
            
            // Positions aléatoires
            const x = Math.random() * 100;
            const y = 80 + Math.random() * 20; // Partir du bas
            const duration = 5 + Math.random() * 10;
            const size = 2 + Math.random() * 3;
            
            particle.style.left = `${x}%`;
            particle.style.top = `${y}%`;
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.opacity = '0.3';
            particle.style.animationDuration = `${duration}s`;
            
            container.appendChild(particle);
            
            // Supprimer et recréer la particule après son animation
            setTimeout(() => {
                particle.remove();
                createParticle();
            }, duration * 1000);
        }
        
        // Initialiser les particules
        createBackgroundParticles();
    });
    </script>
    <script>
// État du jeu
let game = {
    // Ressources
    nanobots: 0,
    totalNanobots: 0,
    clickValue: 1,
    
    // Expansion et zones
    expansion: {
        currentLevel: 0,
        progressToNext: 0,
        levelNames: [
            "Terre", "Système Solaire", "Voie Lactée", 
            "Groupe Local", "Super-amas Local", "Univers Observable",
            "Multivers", "Dimensions Parallèles", "Réalité Quantique"
        ],
        milestones: [
            { name: "Terre", desc: "Point de départ", icon: "globe", unlocked: true, nanobotReq: 0 },
            { name: "Lune", desc: "+10% production", icon: "moon", unlocked: false, nanobotReq: 1e3, effect: () => { applyProductionMultiplier(1.1); } },
            { name: "Mars", desc: "+15% production", icon: "rocket", unlocked: false, nanobotReq: 1e4, effect: () => { applyProductionMultiplier(1.15); } },
            { name: "Système Solaire", desc: "+25% production", icon: "sun", unlocked: false, nanobotReq: 1e6, effect: () => { applyProductionMultiplier(1.25); } },
            { name: "Étoiles Proches", desc: "Débloque nouvel assembleur", icon: "star", unlocked: false, nanobotReq: 1e8, effect: () => { unlockProducer(3); } },
            { name: "Voie Lactée", desc: "+50% production", icon: "galaxy", unlocked: false, nanobotReq: 1e10, effect: () => { applyProductionMultiplier(1.5); } },
            { name: "Galaxies Voisines", desc: "Double valeur des clics", icon: "atom", unlocked: false, nanobotReq: 1e13, effect: () => { game.clickValue *= 2; } },
            { name: "Groupe Local", desc: "+100% production", icon: "meteor", unlocked: false, nanobotReq: 1e16, effect: () => { applyProductionMultiplier(2); } },
            { name: "Super-amas Local", desc: "Débloque évolution quantique", icon: "project-diagram", unlocked: false, nanobotReq: 1e20, effect: () => { unlockProducer(5); } },
            { name: "Univers Observable", desc: "Triple toute production", icon: "microscope", unlocked: false, nanobotReq: 1e25, effect: () => { applyProductionMultiplier(3); } },
            { name: "Multivers", desc: "Débloque réplicateurs ultimes", icon: "cube", unlocked: false, nanobotReq: 1e30, effect: () => { unlockProducer(6); } },
            { name: "Dimensions Parallèles", desc: "x10 à la valeur des clics", icon: "cubes", unlocked: false, nanobotReq: 1e35, effect: () => { game.clickValue *= 10; } },
            { name: "Réalité Quantique", desc: "Maîtrise totale", icon: "infinity", unlocked: false, nanobotReq: 1e40, effect: () => { applyProductionMultiplier(10); } }
        ]
    },
    
    // Producteurs
    producers: [
        { id: 'producer1', name: 'Nano-Assembleur', count: 0, baseCost: 10, costMultiplier: 1.1, production: 0.1, unlocked: true, 
          desc: "Assemble des nanobots individuellement", icon: "microchip" },
        { id: 'producer2', name: 'Réplicateur Moléculaire', count: 0, baseCost: 100, costMultiplier: 1.12, production: 1, unlocked: false, 
          desc: "Réplique les nanobots au niveau moléculaire", icon: "code-branch" },
        { id: 'producer3', name: 'Usine Quantique', count: 0, baseCost: 1500, costMultiplier: 1.15, production: 10, unlocked: false, 
          desc: "Utilise les fluctuations quantiques pour générer des nanobots", icon: "atom" },
        { id: 'producer4', name: 'Matrice Stellaire', count: 0, baseCost: 20000, costMultiplier: 1.17, production: 100, unlocked: false, 
          desc: "Convertit l'énergie stellaire en nanobots", icon: "sun" },
        { id: 'producer5', name: 'Condensateur Galactique', count: 0, baseCost: 500000, costMultiplier: 1.18, production: 1000, unlocked: false, 
          desc: "Condense la matière interstellaire en nanobots", icon: "galaxy" },
        { id: 'producer6', name: 'Transmutateur Quantique', count: 0, baseCost: 10000000, costMultiplier: 1.2, production: 10000, unlocked: false, 
          desc: "Transmute l'énergie du vide en nanobots", icon: "project-diagram" },
        { id: 'producer7', name: 'Générateur Dimensionnel', count: 0, baseCost: 500000000, costMultiplier: 1.22, production: 100000, unlocked: false, 
          desc: "Extrait des nanobots d'autres dimensions", icon: "cube" }
    ],
    
    // Améliorations
    upgrades: [
        { id: 'upgrade1', name: 'Protocole d\'auto-réplication', description: 'Double la valeur de vos clics', cost: 50, purchased: false, 
          effect: () => { game.clickValue *= 2; }, icon: "hand-pointer" },
        { id: 'upgrade2', name: 'Nano-processeurs avancés', description: 'Double la production des Nano-Assembleurs', cost: 200, purchased: false, 
          effect: () => { 
              // Recherche du producteur par ID pour plus de robustesse
              const producerIndex = game.producers.findIndex(p => p.id === 'producer1');
              if (producerIndex !== -1) {
                  multiplyProducerProduction(producerIndex, 2);
              } else {
                  console.error("Producteur 'Nano-Assembleur' non trouvé pour l'amélioration");
              }
          }, 
          requirement: () => {
              // Recherche du producteur par ID pour plus de robustesse
              const producer = game.producers.find(p => p.id === 'producer1');
              return producer && producer.count >= 10;
          }, 
          icon: "microchip" 
        },
        { id: 'upgrade3', name: 'Algorithmes adaptatifs', description: 'Triple la production des Réplicateurs Moléculaires', cost: 1000, purchased: false, 
          effect: () => {
              const producerIndex = game.producers.findIndex(p => p.id === 'producer2');
              if (producerIndex !== -1) {
                  multiplyProducerProduction(producerIndex, 3);
              } else {
                  console.error("Producteur 'Réplicateur Moléculaire' non trouvé pour l'amélioration");
              }
          },
          requirement: () => {
              const producer = game.producers.find(p => p.id === 'producer2');
              return producer && producer.count >= 10;
          },
          icon: "brain" 
        },
        { id: 'upgrade4', name: 'Manipulation atomique', description: 'Double la production de tous les producteurs', cost: 5000, purchased: false, 
          effect: () => { applyProductionMultiplier(2); }, 
          requirement: () => game.totalNanobots >= 2000, 
          icon: "atom" 
        },
        { id: 'upgrade5', name: 'Compression moléculaire', description: 'Tous les coûts -10%', cost: 20000, purchased: false, 
          effect: () => { applyCostReduction(0.9); }, 
          requirement: () => game.expansion && game.expansion.currentLevel >= 1, 
          icon: "compress" 
        },
        { id: 'upgrade6', name: 'Intelligence collective', description: 'Production +50% par zone débloquée', cost: 100000, purchased: false, 
          effect: () => { 
              if (typeof recalculateCollectiveIntelligence === 'function') {
                  recalculateCollectiveIntelligence();
              } else {
                  // Fallback si la fonction n'existe pas
                  applyProductionMultiplier(1.5);
              }
          }, 
          requirement: () => game.expansion && game.expansion.currentLevel >= 2, 
          icon: "network-wired" 
        },
        { id: 'upgrade7', name: 'Manipulation quantique', description: 'Quadruple la production des Usines Quantiques', cost: 500000, purchased: false, 
          effect: () => {
              const producerIndex = game.producers.findIndex(p => p.id === 'producer3');
              if (producerIndex !== -1) {
                  multiplyProducerProduction(producerIndex, 4);
              } else {
                  console.error("Producteur 'Usine Quantique' non trouvé pour l'amélioration");
              }
          },
          requirement: () => {
              const producer = game.producers.find(p => p.id === 'producer3');
              return producer && producer.count >= 15;
          },
          icon: "dice-d20" 
        },
        { id: 'upgrade8', name: 'Matière noire', description: 'Production x5 pendant 30 secondes', cost: 2000000, purchased: false, 
          effect: () => { 
              if (typeof applyTemporaryBoost === 'function') {
                  applyTemporaryBoost(5, 30);
              } else {
                  // Fallback si la fonction n'existe pas
                  applyProductionMultiplier(5);
              }
          }, 
          requirement: () => game.expansion && game.expansion.currentLevel >= 3, 
          icon: "star-half-alt" 
        },
        { id: 'upgrade9', name: 'Singularité technologique', description: 'Production x10 mais consomme 1% de nanobots/sec', cost: 50000000, purchased: false, 
          effect: () => { 
              if (typeof applySingularity === 'function') {
                  applySingularity();
              } else {
                  // Fallback si la fonction n'existe pas
                  applyProductionMultiplier(10);
              }
          }, 
          requirement: () => game.expansion && game.expansion.currentLevel >= 5, 
          icon: "bullseye" 
        }
    ],
    
    // Prestige (évolution nanobotique)
    prestige: {
        points: 0,
        multiplier: 1,
        toGain: 0,
        unlocked: false
    },
    
    // Boosts temporaires
    temporaryBoosts: [],
    
    // Statistiques
    stats: {
        clickCount: 0,
        playTime: 0,
        prestigeCount: 0
    },
    
    // Timing et sauvegarde
    lastUpdate: Date.now(),
    lastSave: null,
    
    // Paramètres et préférences
    settings: {
        showAutoSaveNotification: true,   // Afficher ou non les notifications de sauvegarde automatique
        theme: 'dark'                     // Thème actuel (dark ou light)
    },
    
    // Système de succès
    achievementBonus: 0,                  // Bonus de production (+1% par succès)
    achievements: [
        { 
            id: 'achievement1',
            name: 'Premier pas',
            description: 'Produire 100 nanobots au total',
            icon: 'baby',
            unlocked: false,
            condition: () => game.totalNanobots >= 100,
            rewardText: '+1% de production'
        },
        {
            id: 'achievement2',
            name: 'Expansion locale',
            description: 'Atteindre le niveau Lune',
            icon: 'moon',
            unlocked: false,
            condition: () => game.expansion.milestones.find(m => m.name === "Lune")?.unlocked,
            rewardText: '+1% de production'
        },
        {
            id: 'achievement3',
            name: 'Usine à nanobots',
            description: 'Posséder 10 Nano-Assembleurs',
            icon: 'industry',
            unlocked: false,
            condition: () => game.producers[0].count >= 10,
            rewardText: '+1% de production'
        },
        {
            id: 'achievement4',
            name: 'Cliqueur professionnel',
            description: 'Cliquer 100 fois',
            icon: 'hand-pointer',
            unlocked: false,
            condition: () => game.stats.clickCount >= 100,
            rewardText: '+1% de production'
        },
        {
            id: 'achievement5',
            name: 'Millionnaire',
            description: 'Produire 1 million de nanobots au total',
            icon: 'chart-line',
            unlocked: false,
            condition: () => game.totalNanobots >= 1e6,
            rewardText: '+1% de production'
        },
        {
            id: 'achievement6',
            name: 'Premier système',
            description: 'Atteindre le niveau Système Solaire',
            icon: 'sun',
            unlocked: false,
            condition: () => game.expansion.milestones.find(m => m.name === "Système Solaire")?.unlocked,
            rewardText: '+1% de production'
        },
        {
            id: 'achievement7',
            name: 'Collection complète',
            description: 'Posséder au moins 1 exemplaire de chaque producteur débloqué',
            icon: 'layer-group',
            unlocked: false,
            condition: () => {
                const unlockedProducers = game.producers.filter(p => p.unlocked);
                return unlockedProducers.every(p => p.count > 0);
            },
            rewardText: '+1% de production'
        },
        {
            id: 'achievement8',
            name: 'Renaissance',
            description: 'Effectuer un prestige',
            icon: 'sync-alt',
            unlocked: false,
            condition: () => game.stats.prestigeCount > 0,
            rewardText: '+1% de production'
        }
    ]
};

// Éléments DOM
const elements = {
    nanobots: document.getElementById('nanobots'),
    perSecond: document.getElementById('per-second'),
    clickValue: document.getElementById('click-value'),
    expansionLevel: document.getElementById('expansion-level'),
    expansionProgress: document.getElementById('expansion-progress'),
    expansionPercent: document.getElementById('expansion-percent'),
    clicker: document.getElementById('clicker'),
    producersContainer: document.getElementById('producers-container'),
    upgradesContainer: document.getElementById('upgrades-container'),
    milestonesContainer: document.getElementById('milestones-container'),
    prestigePoints: document.getElementById('prestige-points'),
    prestigeMultiplier: document.getElementById('prestige-multiplier'),
    prestigeToGain: document.getElementById('prestige-to-gain'),
    prestigeButton: document.getElementById('prestige-button'),
    saveButton: document.getElementById('save-button'),
    resetButton: document.getElementById('reset-button'),
    themeToggle: document.getElementById('theme-toggle'),
    lastSave: document.getElementById('last-save'),
    achievementsContainer: document.getElementById('achievements-container'),
    achievementsBonus: document.getElementById('achievements-bonus')
};

// Fonctions utilitaires
function formatNumber(num) {
    if (num < 1000) return num.toFixed(1).replace(/\.0$/, '');
    
    const units = ['', 'K', 'M', 'B', 'T', 'Qa', 'Qi', 'Sx', 'Sp', 'Oc', 'No', 'Dc', 'UDc', 'DDc', 'TDc', 'QaDc', 'QiDc'];
    const exponent = Math.floor(Math.log10(num) / 3);
    const unit = units[exponent] || `e${exponent*3}`;
    
    return (num / Math.pow(10, exponent * 3)).toFixed(2).replace(/\.00$/, '') + unit;
}

// Fonction pour arrêter la boucle de jeu proprement
function stopGameLoop() {
    if (game.gameLoopId) {
        cancelAnimationFrame(game.gameLoopId);
        game.gameLoopId = null;
    }
}

function formatTime(timestamp) {
    if (!timestamp) return 'Jamais';
    const date = new Date(timestamp);
    return date.toLocaleTimeString();
}

// Fonction pour calculer la production par seconde
function calculateProduction() {
    // Protection contre les NaN
    try {
        let production = 0;
        
        // Vérifier que game.producers existe et est un tableau
        if (Array.isArray(game.producers)) {
            game.producers.forEach(producer => {
                // Vérifier que les valeurs sont numériques
                const count = Number(producer.count) || 0;
                const prodValue = Number(producer.production) || 0;
                production += count * prodValue;
            });
        }
        
        // Appliquer multiplicateur de prestige avec vérification
        const prestigeMultiplier = Number(game.prestige?.multiplier) || 1;
        production *= prestigeMultiplier;
        
        // Appliquer boosts temporaires
        if (Array.isArray(game.temporaryBoosts)) {
            game.temporaryBoosts.forEach(boost => {
                const boostMultiplier = Number(boost.multiplier) || 1;
                production *= boostMultiplier;
            });
        }
        
        // Appliquer le bonus des succès (+1% par succès débloqué)
        const achievementBonus = Number(game.achievementBonus) || 0;
        if (achievementBonus > 0) {
            production *= (1 + (achievementBonus * 0.01));
        }
        
        // Protection finale contre NaN ou valeurs négatives
        if (isNaN(production) || production < 0) {
            console.error("Production invalide calculée:", production);
            return 0;
        }
        
        return production;
    } catch (error) {
        console.error("Erreur dans le calcul de production:", error);
        return 0;
    }
}

// Fonction pour calculer le coût d'un producteur
function getProducerCost(producer) {
    try {
        // Log pour débogage
        console.log('getProducerCost pour:', producer.name, 'baseCost:', producer.baseCost, 'count:', producer.count, 'costMultiplier:', producer.costMultiplier);
        
        // Vérification stricte que le producteur est un objet valide
        if (!producer || typeof producer !== 'object') {
            console.error("Producteur invalide passé à getProducerCost:", producer);
            return 10; // Valeur par défaut en cas d'erreur
        }
        
        // Vérification que les valeurs sont numériques avec conversion explicite
        const baseCost = parseFloat(producer.baseCost);
        const costMultiplier = parseFloat(producer.costMultiplier);
        const count = parseInt(producer.count);
        
        // Vérification supplémentaire avec valeurs de secours
        const validBaseCost = isNaN(baseCost) ? 10 : baseCost; 
        const validMultiplier = (isNaN(costMultiplier) || costMultiplier < 1) ? 1.1 : costMultiplier;
        const validCount = isNaN(count) ? 0 : count;
        
        console.log('Valeurs validées:', 'baseCost:', validBaseCost, 'costMultiplier:', validMultiplier, 'count:', validCount);
        
        // Calcul du coût avec une limitation pour éviter des valeurs extrêmes
        const cost = Math.floor(validBaseCost * Math.pow(validMultiplier, validCount));
        
        console.log('Coût calculé avant validation:', cost);
        
        // Protection contre NaN, infini ou valeurs négatives
        if (isNaN(cost) || !isFinite(cost) || cost <= 0) {
            console.error("Coût de producteur invalide calculé:", cost);
            return validBaseCost; // Revenir à la base par défaut
        }
        
        console.log('Coût final retourné:', cost, 'type:', typeof cost);
        return cost;
    } catch (error) {
        console.error("Erreur dans le calcul du coût du producteur:", error);
        return producer.baseCost || 10; // Valeur par défaut
    }
}

/**
 * Version robuste qui fusionne et nettoie un état de jeu chargé avec un état par défaut
 * @param {Object} loadedState - L'état chargé (potentiellement incomplet ou corrompu)
 * @param {Object} defaultState - L'état par défaut complet (résultat de getDefaultGameState())
 * @returns {Object} - Un nouvel état de jeu propre et complet
 */
function sanitizeGameState(loadedState, defaultState) {
    console.log("Sanitization de l'état du jeu...");
    
    // Si loadedState est null/undefined ou pas un objet, retourner une copie de defaultState
    if (!loadedState || typeof loadedState !== 'object') {
        console.warn("État chargé invalide, utilisation de l'état par défaut");
        return JSON.parse(JSON.stringify(defaultState));
    }
    
    // Créer un nouvel objet à partir de defaultState
    const sanitizedState = JSON.parse(JSON.stringify(defaultState));
    
    try {
        // 1. Copier les propriétés primitives simples avec vérification de type
        const numericProps = ['nanobots', 'totalNanobots', 'clickValue', 'achievementBonus'];
        numericProps.forEach(prop => {
            if (typeof loadedState[prop] === 'number' && !isNaN(loadedState[prop])) {
                // Pour clickValue, ne jamais descendre en dessous de 1
                if (prop === 'clickValue') {
                    sanitizedState[prop] = Math.max(1, loadedState[prop]);
                } else {
                    // Pour les autres propriétés numériques, ne jamais descendre en dessous de 0
                    sanitizedState[prop] = Math.max(0, loadedState[prop]);
                }
            } else {
                console.warn(`Propriété numérique invalide: ${prop}, utilisation de la valeur par défaut`);
            }
        });
        
        // Copier les timestamps
        if (typeof loadedState.lastUpdate === 'number' && !isNaN(loadedState.lastUpdate)) {
            sanitizedState.lastUpdate = loadedState.lastUpdate;
        }
        if (typeof loadedState.lastSave === 'number' && !isNaN(loadedState.lastSave)) {
            sanitizedState.lastSave = loadedState.lastSave;
        }
        
        // 2. Fusionner les statistiques
        if (loadedState.stats && typeof loadedState.stats === 'object') {
            Object.keys(defaultState.stats).forEach(statKey => {
                if (typeof loadedState.stats[statKey] === 'number' && !isNaN(loadedState.stats[statKey])) {
                    sanitizedState.stats[statKey] = Math.max(0, loadedState.stats[statKey]);
                }
            });
        }
        
        // 3. Fusionner les paramètres utilisateur
        if (loadedState.settings && typeof loadedState.settings === 'object') {
            // Conserver tous les paramètres du state par défaut
            Object.keys(loadedState.settings).forEach(settingKey => {
                if (settingKey in defaultState.settings) {
                    // Cas spécial pour le thème
                    if (settingKey === 'theme') {
                        sanitizedState.settings.theme = 
                            (loadedState.settings.theme === 'light' || loadedState.settings.theme === 'dark') 
                                ? loadedState.settings.theme 
                                : defaultState.settings.theme;
                    } else if (typeof loadedState.settings[settingKey] === typeof defaultState.settings[settingKey]) {
                        // Pour les autres paramètres, copier si le type correspond
                        sanitizedState.settings[settingKey] = loadedState.settings[settingKey];
                    }
                }
            });
        }
        
        // 4. Fusionner les producteurs
        if (Array.isArray(loadedState.producers)) {
            loadedState.producers.forEach((loadedProducer, index) => {
                if (loadedProducer && typeof loadedProducer === 'object' && index < sanitizedState.producers.length) {
                    const sanitizedProducer = sanitizedState.producers[index];
                    
                    // Transférer propriétés numériques avec validation
                    if (typeof loadedProducer.count === 'number' && !isNaN(loadedProducer.count)) {
                        sanitizedProducer.count = Math.max(0, loadedProducer.count);
                    }
                    
                    if (typeof loadedProducer.production === 'number' && !isNaN(loadedProducer.production) && loadedProducer.production > 0) {
                        sanitizedProducer.production = loadedProducer.production;
                    }
                    
                    if (typeof loadedProducer.costMultiplier === 'number' && !isNaN(loadedProducer.costMultiplier) && loadedProducer.costMultiplier >= 1) {
                        sanitizedProducer.costMultiplier = loadedProducer.costMultiplier;
                    }
                    
                    // État de déverrouillage
                    if (typeof loadedProducer.unlocked === 'boolean') {
                        sanitizedProducer.unlocked = loadedProducer.unlocked;
                    }
                }
            });
        }
        
        // 5. Fusionner les améliorations
        if (Array.isArray(loadedState.upgrades)) {
            loadedState.upgrades.forEach((loadedUpgrade, index) => {
                if (loadedUpgrade && typeof loadedUpgrade === 'object' && index < sanitizedState.upgrades.length) {
                    // Seul l'état d'achat est repris, les autres propriétés viennent de l'état par défaut
                    if (typeof loadedUpgrade.purchased === 'boolean') {
                        sanitizedState.upgrades[index].purchased = loadedUpgrade.purchased;
                    }
                    
                    // Conserver le coût si présent
                    if (typeof loadedUpgrade.cost === 'number' && !isNaN(loadedUpgrade.cost) && loadedUpgrade.cost > 0) {
                        sanitizedState.upgrades[index].cost = loadedUpgrade.cost;
                    }
                }
            });
        }
        
        // 6. Fusionner le système de prestige
        if (loadedState.prestige && typeof loadedState.prestige === 'object') {
            // Points et multiplicateur
            if (typeof loadedState.prestige.points === 'number' && !isNaN(loadedState.prestige.points)) {
                sanitizedState.prestige.points = Math.max(0, loadedState.prestige.points);
            }
            
            if (typeof loadedState.prestige.multiplier === 'number' && !isNaN(loadedState.prestige.multiplier)) {
                sanitizedState.prestige.multiplier = Math.max(1, loadedState.prestige.multiplier);
            }
            
            // État de déverrouillage
            if (typeof loadedState.prestige.unlocked === 'boolean') {
                sanitizedState.prestige.unlocked = loadedState.prestige.unlocked;
            }
            
            // Points à gagner
            if (typeof loadedState.prestige.toGain === 'number' && !isNaN(loadedState.prestige.toGain)) {
                sanitizedState.prestige.toGain = Math.max(0, loadedState.prestige.toGain);
            }
        }
        
        // 7. Fusionner le système d'expansion
        if (loadedState.expansion && typeof loadedState.expansion === 'object') {
            // Niveau actuel
            if (typeof loadedState.expansion.currentLevel === 'number' && !isNaN(loadedState.expansion.currentLevel)) {
                sanitizedState.expansion.currentLevel = Math.max(0, Math.min(
                    loadedState.expansion.currentLevel,
                    sanitizedState.expansion.levelNames.length - 1
                ));
            }
            
            // Progression
            if (typeof loadedState.expansion.progressToNext === 'number' && !isNaN(loadedState.expansion.progressToNext)) {
                sanitizedState.expansion.progressToNext = Math.max(0, Math.min(1, loadedState.expansion.progressToNext));
            }
            
            // État de déverrouillage
            if (typeof loadedState.expansion.unlocked === 'boolean') {
                sanitizedState.expansion.unlocked = loadedState.expansion.unlocked;
            }
            
            // Fusionner les jalons
            if (Array.isArray(loadedState.expansion.milestones)) {
                loadedState.expansion.milestones.forEach((loadedMilestone, index) => {
                    if (loadedMilestone && typeof loadedMilestone === 'object' && 
                        index < sanitizedState.expansion.milestones.length) {
                        // Seul l'état de déverrouillage est préservé, le reste vient de l'état par défaut
                        if (typeof loadedMilestone.unlocked === 'boolean') {
                            sanitizedState.expansion.milestones[index].unlocked = loadedMilestone.unlocked;
                        }
                    }
                });
            }
        }
        
        // 8. Fusionner les succès
        if (Array.isArray(loadedState.achievements)) {
            // Récupérer les états de déverrouillage des succès existants
            loadedState.achievements.forEach(loadedAchievement => {
                if (loadedAchievement && typeof loadedAchievement === 'object' && loadedAchievement.id) {
                    const matchingAchievement = sanitizedState.achievements.find(a => a.id === loadedAchievement.id);
                    if (matchingAchievement && typeof loadedAchievement.unlocked === 'boolean') {
                        matchingAchievement.unlocked = loadedAchievement.unlocked;
                    }
                }
            });
            
            // Recalculer le bonus d'achievements
            const unlockedCount = sanitizedState.achievements.filter(a => a.unlocked).length;
            sanitizedState.achievementBonus = unlockedCount;
        }
        
        // 9. Copier les boosts temporaires si présents
        if (Array.isArray(loadedState.temporaryBoosts)) {
            // Filtrer pour s'assurer que tous les boosts sont valides
            sanitizedState.temporaryBoosts = loadedState.temporaryBoosts
                .filter(boost => 
                    boost && 
                    typeof boost === 'object' && 
                    typeof boost.multiplier === 'number' && 
                    !isNaN(boost.multiplier) &&
                    typeof boost.expiryTime === 'number' && 
                    !isNaN(boost.expiryTime) &&
                    boost.expiryTime > Date.now() // Ne pas copier les boosts expirés
                )
                .map(boost => ({
                    multiplier: Math.max(1, boost.multiplier),
                    expiryTime: boost.expiryTime
                }));
        }
        
        // 10. Vérification finale des propriétés critiques
        // Si après fusion certaines structures essentielles sont toujours manquantes, les recréer
        if (!sanitizedState.expansion) {
            console.error("Structure d'expansion manquante après fusion");
            sanitizedState.expansion = JSON.parse(JSON.stringify(defaultState.expansion));
        }
        
        if (!sanitizedState.prestige) {
            console.error("Structure de prestige manquante après fusion");
            sanitizedState.prestige = JSON.parse(JSON.stringify(defaultState.prestige));
        }
        
        if (!Array.isArray(sanitizedState.producers) || sanitizedState.producers.length === 0) {
            console.error("Producteurs manquants après fusion");
            sanitizedState.producers = JSON.parse(JSON.stringify(defaultState.producers));
        }
        
        if (!Array.isArray(sanitizedState.upgrades) || sanitizedState.upgrades.length === 0) {
            console.error("Améliorations manquantes après fusion");
            sanitizedState.upgrades = JSON.parse(JSON.stringify(defaultState.upgrades));
        }
        
        console.log("Sanitization terminée avec succès");
        return sanitizedState;
        
    } catch (error) {
        console.error("Erreur lors de la sanitization de l'état du jeu:", error);
        // En cas d'erreur grave, retourner l'état par défaut
        return JSON.parse(JSON.stringify(defaultState));
    }
}

// Fonction pour obtenir un état de jeu par défaut
function getDefaultGameState() {
    // Création d'un nouvel état par défaut à chaque appel
    // en utilisant Date.now() à l'intérieur de la fonction pour garantir une valeur fraiche
    const defaultState = {
        // Valeurs de base
        nanobots: 0,
        totalNanobots: 0,
        clickValue: 1,
        lastUpdate: Date.now(),
        lastSave: Date.now(),
        
        // Flags et états du système
        gameLoopId: null,
        saveIntervalId: null,
        hasSaveLoaded: false,
        singularityActive: false,
        offlineGainNotification: null,
        
        // Statistiques de jeu
        stats: {
            clickCount: 0,
            playTime: 0,
            prestigeCount: 0,
            totalReset: 0
        },
        
        // Producteurs (générateurs de nanobots)
        producers: [
            { id: 'producer1', name: 'Nano-Assembleur', count: 0, baseCost: 10, costMultiplier: 1.1, production: 0.1, unlocked: true, 
              desc: "Assemble des nanobots individuellement", icon: "microchip" },
            { id: 'producer2', name: 'Réplicateur Moléculaire', count: 0, baseCost: 100, costMultiplier: 1.12, production: 1, unlocked: false, 
              desc: "Réplique les nanobots au niveau moléculaire", icon: "code-branch" },
            { id: 'producer3', name: 'Usine Quantique', count: 0, baseCost: 1500, costMultiplier: 1.15, production: 10, unlocked: false, 
              desc: "Utilise les fluctuations quantiques pour générer des nanobots", icon: "atom" },
            { id: 'producer4', name: 'Matrice Stellaire', count: 0, baseCost: 20000, costMultiplier: 1.17, production: 100, unlocked: false, 
              desc: "Convertit l'énergie stellaire en nanobots", icon: "sun" },
            { id: 'producer5', name: 'Condensateur Galactique', count: 0, baseCost: 500000, costMultiplier: 1.18, production: 1000, unlocked: false, 
              desc: "Condense la matière interstellaire en nanobots", icon: "galaxy" }
        ],
        
        // Améliorations
        upgrades: [
            { id: 'upgrade1', name: 'Protocole d\'auto-réplication', description: 'Double la valeur de vos clics', cost: 50, purchased: false, 
              effect: function() { game.clickValue *= 2; }, icon: "hand-pointer" },
            { id: 'upgrade2', name: 'Nano-processeurs avancés', description: 'Double la production des Nano-Assembleurs', cost: 200, purchased: false, 
              effect: function() { 
                  const producerIndex = game.producers.findIndex(p => p.id === 'producer1');
                  if (producerIndex !== -1) {
                      multiplyProducerProduction(producerIndex, 2);
                  }
              }, 
              requirement: function() {
                  const producer = game.producers.find(p => p.id === 'producer1');
                  return producer && producer.count >= 10;
              }, 
              icon: "microchip" 
            },
            { id: 'upgrade3', name: 'Algorithmes adaptatifs', description: 'Triple la production des Réplicateurs Moléculaires', cost: 1000, purchased: false, 
              effect: function() {
                  const producerIndex = game.producers.findIndex(p => p.id === 'producer2');
                  if (producerIndex !== -1) {
                      multiplyProducerProduction(producerIndex, 3);
                  }
              },
              requirement: function() {
                  const producer = game.producers.find(p => p.id === 'producer2');
                  return producer && producer.count >= 10;
              },
              icon: "brain" 
            },
            { id: 'upgrade4', name: 'Manipulation atomique', description: 'Double la production de tous les producteurs', cost: 5000, purchased: false, 
              effect: function() { applyProductionMultiplier(2); }, 
              requirement: function() { return game.totalNanobots >= 2000; }, 
              icon: "atom" 
            }
        ],
        
        // Système de prestige
        prestige: {
            unlocked: false,
            points: 0,
            multiplier: 1,
            required: 1e12, // 1 trillion
            toGain: 0
        },
        
        // Système d'expansion
        expansion: {
            unlocked: false,
            currentLevel: 0,
            progressToNext: 0,
            levelNames: [
                "Terre", "Système Solaire", "Voie Lactée", 
                "Groupe Local", "Super-amas Local", "Univers Observable",
                "Multivers", "Dimensions Parallèles", "Réalité Quantique", "Omnipresence"
            ],
            levels: [
                { name: 'Microscopic', description: 'Les nanobots se rassemblent en colonies microscopiques' },
                { name: 'Macroscopic', description: 'Les colonies deviennent visibles à l\'œil nu' },
                { name: 'Planetary', description: 'Les nanobots commencent à se répandre sur toute la planète' },
                { name: 'Interplanetary', description: 'Expansion vers d\'autres planètes du système solaire' },
                { name: 'Interstellar', description: 'Les sondes de nanobots atteignent les étoiles voisines' },
                { name: 'Galactic', description: 'Présence établie dans toute la Voie Lactée' },
                { name: 'Intergalactic', description: 'Expansion vers d\'autres galaxies' },
                { name: 'Universal', description: 'Présence dans tout l\'univers observable' },
                { name: 'Multidimensional', description: 'Découverte et exploration d\'autres dimensions' },
                { name: 'Omnipresent', description: 'Présence transcendant l\'espace et le temps' }
            ],
            milestones: [
                { id: 'milestone1', nanobotReq: 100, name: 'Premier Jalon', description: 'Débloque une voie de développement améliorée', 
                  icon: 'star', unlocked: false, effect: function() { game.clickValue += 1; } },
                { id: 'milestone2', nanobotReq: 10000, name: 'Optimisation', description: 'Optimisation du réseau de nanobots', 
                  icon: 'trophy', unlocked: false, effect: function() { game.producers[1].unlocked = true; } },
                { id: 'milestone3', nanobotReq: 1000000, name: 'Intelligence Collective', description: 'Intelligence collective émergente', 
                  icon: 'brain', unlocked: false, effect: function() { game.clickValue *= 2; } },
                { id: 'milestone4', nanobotReq: 100000000, name: 'Intégration Quantique', description: 'Intégration quantique', 
                  icon: 'atom', unlocked: false, effect: function() { game.producers[2].unlocked = true; } },
                { id: 'milestone5', nanobotReq: 10000000000, name: 'Conscience', description: 'Conscience technologique', 
                  icon: 'robot', unlocked: false, effect: function() { applyProductionMultiplier(3); } },
                { id: 'milestone6', nanobotReq: 1000000000000, name: 'Singularité', description: 'Singularité nano-technologique', 
                  icon: 'infinity', unlocked: false, effect: function() { game.prestige.unlocked = true; } }
            ]
        },
        
        // Paramètres utilisateur
        settings: {
            showAutoSaveNotification: true,
            theme: 'dark',
            particleEffects: true,
            showTutorial: true
        },
        
        // Boosts temporaires
        temporaryBoosts: [],
        
        // Système d'accomplissements
        achievements: [
            { 
                id: 'ach1', 
                name: 'Premier Pas', 
                description: 'Produire votre premier nanobot', 
                unlocked: false, 
                icon: 'fas fa-baby',
                condition: function() { return game.nanobots >= 1; },
                rewardText: "+1% production"
            },
            { 
                id: 'ach2', 
                name: 'Automatisation', 
                description: 'Acheter votre premier producteur', 
                unlocked: false, 
                icon: 'fas fa-cog',
                condition: function() { return game.producers.some(p => p.count > 0); },
                rewardText: "+1% production"
            },
            { 
                id: 'ach3', 
                name: 'Collectionneur', 
                description: 'Posséder au moins un de chaque producteur', 
                unlocked: false, 
                icon: 'fas fa-layer-group',
                condition: function() { return game.producers.every(p => p.count > 0); },
                rewardText: "+1% production"
            },
            { 
                id: 'ach4', 
                name: 'Clicker Pro', 
                description: 'Cliquer 100 fois', 
                unlocked: false, 
                icon: 'fas fa-hand-pointer',
                condition: function() { return game.stats && game.stats.clickCount >= 100; },
                rewardText: "+1% production"
            },
            { 
                id: 'ach5', 
                name: 'Expansion', 
                description: 'Atteindre le niveau d\'expansion 3', 
                unlocked: false, 
                icon: 'fas fa-expand-arrows-alt',
                condition: function() { return game.expansion && game.expansion.currentLevel >= 3; },
                rewardText: "+1% production"
            },
            { 
                id: 'ach6', 
                name: 'Milliardaire', 
                description: 'Produire 1 milliard de nanobots', 
                unlocked: false, 
                icon: 'fas fa-money-bill-wave',
                condition: function() { return game.totalNanobots >= 1e9; },
                rewardText: "+1% production"
            },
            { 
                id: 'ach7', 
                name: 'Transcendance', 
                description: 'Effectuer votre premier prestige', 
                unlocked: false, 
                icon: 'fas fa-sync-alt',
                condition: function() { return game.prestige && game.prestige.points > 0; },
                rewardText: "+1% production"
            },
            { 
                id: 'ach8', 
                name: 'Maître de l\'Univers', 
                description: 'Atteindre le niveau d\'expansion 10', 
                unlocked: false, 
                icon: 'fas fa-globe',
                condition: function() { return game.expansion && game.expansion.currentLevel >= 10; },
                rewardText: "+1% production"
            }
        ],
        achievementBonus: 0
    };
    
    // IMPORTANT: Retourner l'état par défaut
    return defaultState;
}

// Fonction pour calculer les points de prestige à gagner
function calculatePrestigeGain() {
    try {
        // Vérifier que totalNanobots est un nombre valide
        const totalNanobots = Number(game.totalNanobots) || 0;
        
        // Protection contre les valeurs négatives
        if (totalNanobots <= 0) return 0;
        
        // Formule: racine carrée de (nanobots totaux / 1e10)
        const gain = Math.floor(Math.sqrt(totalNanobots / 1e10));
        
        // S'assurer que le gain est un nombre positif ou nul
        return (isNaN(gain) || gain < 0) ? 0 : gain;
    } catch (error) {
        console.error("Erreur dans le calcul du gain de prestige:", error);
        return 0;
    }
}

// Fonction pour appliquer un multiplicateur à la production
function applyProductionMultiplier(multiplier) {
    try {
        // Vérifier que le multiplicateur est un nombre valide et positif
        const multValue = Number(multiplier);
        if (isNaN(multValue) || multValue <= 0) {
            console.error("Multiplicateur de production invalide:", multiplier);
            return;
        }
        
        // Appliquer le multiplicateur à tous les producteurs
        if (Array.isArray(game.producers)) {
            game.producers.forEach(producer => {
                producer.production = Number(producer.production) || 0;
                producer.production *= multValue;
                
                // Protection contre NaN ou valeurs négatives
                if (isNaN(producer.production) || producer.production < 0) {
                    console.warn(`Production invalide pour ${producer.name}, réinitialisation`);
                    producer.production = 0.1; // Valeur par défaut
                }
            });
        }
    } catch (error) {
        console.error("Erreur lors de l'application du multiplicateur de production:", error);
    }
}

// Fonction pour multiplier la production d'un producteur spécifique
function multiplyProducerProduction(index, multiplier) {
    try {
        // Vérifier que l'index et le multiplicateur sont valides
        const multValue = Number(multiplier);
        if (isNaN(multValue) || multValue <= 0) {
            console.error("Multiplicateur de production invalide:", multiplier);
            return;
        }
        
        if (Array.isArray(game.producers) && index >= 0 && index < game.producers.length) {
            const producer = game.producers[index];
            producer.production = Number(producer.production) || 0;
            producer.production *= multValue;
            
            // Protection contre NaN ou valeurs négatives
            if (isNaN(producer.production) || producer.production < 0) {
                console.warn(`Production invalide pour le producteur à l'index ${index}, réinitialisation`);
                producer.production = 0.1 * Math.pow(10, index); // Valeur par défaut basée sur l'index
            }
        }
    } catch (error) {
        console.error("Erreur lors de la multiplication de la production d'un producteur:", error);
    }
}

// Fonction pour appliquer une réduction de coût
function applyCostReduction(factor) {
    try {
        // Vérifier que le facteur est un nombre valide et positif
        const factorValue = Number(factor);
        if (isNaN(factorValue) || factorValue <= 0 || factorValue > 1) {
            console.error("Facteur de réduction de coût invalide:", factor);
            return;
        }
        
        if (Array.isArray(game.producers)) {
            game.producers.forEach(producer => {
                // Assurez-vous que costMultiplier est un nombre
                producer.costMultiplier = Number(producer.costMultiplier) || 1.1;
                producer.costMultiplier = producer.costMultiplier * factorValue + (1 - factorValue);
                
                // Protection contre NaN ou valeurs trop basses/hautes
                if (isNaN(producer.costMultiplier) || producer.costMultiplier < 1.01) {
                    console.warn(`Multiplicateur de coût invalide pour ${producer.name}, réinitialisation`);
                    producer.costMultiplier = 1.1; // Valeur par défaut
                }
            });
        }
    } catch (error) {
        console.error("Erreur lors de l'application de la réduction de coût:", error);
    }
}

// Fonction pour déverrouiller un producteur
function unlockProducer(index) {
    if (index >= 0 && index < game.producers.length) {
        game.producers[index].unlocked = true;
    }
}

// Fonction pour recalculer l'intelligence collective
function recalculateCollectiveIntelligence() {
    // Compte le nombre de jalons débloqués
    const unlockedMilestones = game.expansion.milestones.filter(m => m.unlocked).length;
    // +50% par jalon débloqué
    const multiplier = 1 + (unlockedMilestones * 0.5);
    applyProductionMultiplier(multiplier);
}

// Fonction pour appliquer un boost temporaire
function applyTemporaryBoost(multiplier, durationSeconds) {
    const boost = {
        multiplier: multiplier,
        expiryTime: Date.now() + (durationSeconds * 1000)
    };
    
    game.temporaryBoosts.push(boost);
}

// Fonction pour appliquer la singularité
function applySingularity() {
    // Production x10 mais consommation de 1% des nanobots par seconde
    applyProductionMultiplier(10);
    
    // Logique de consommation implémentée dans la boucle de jeu
    game.singularityActive = true;
}

// Fonction pour vérifier et débloquer des jalons
function checkMilestones() {
    try {
        let updated = false;
        
        // Vérifier que l'expansion et ses jalons existent
        if (!game.expansion || !Array.isArray(game.expansion.milestones)) {
            console.error("Structure d'expansion invalide lors de la vérification des jalons");
            return false;
        }
        
        // Vérifier les jalons un par un
        game.expansion.milestones.forEach(milestone => {
            if (!milestone || typeof milestone !== 'object') return;
            
            // Vérifier si le jalon est déverrouillable
            if (!milestone.unlocked && 
                typeof milestone.nanobotReq === 'number' && 
                game.totalNanobots >= milestone.nanobotReq) {
                
                milestone.unlocked = true;
                updated = true;
                
                // Appliquer l'effet du jalon s'il existe
                if (typeof milestone.effect === 'function') {
                    try {
                        milestone.effect();
                    } catch (effectError) {
                        console.error(`Erreur lors de l'application de l'effet du jalon ${milestone.name}:`, effectError);
                    }
                }
                
                // Notification de déblocage
                try {
                    createNotification(`Jalon débloqué: ${milestone.name}`);
                } catch (notifError) {
                    console.error("Erreur lors de la création de notification:", notifError);
                }
            }
        });
        
        // Mettre à jour le niveau d'expansion
        try {
            updateExpansionLevel();
        } catch (expansionError) {
            console.error("Erreur lors de la mise à jour du niveau d'expansion:", expansionError);
        }
        
        return updated;
    } catch (error) {
        console.error("Erreur lors de la vérification des jalons:", error);
        return false;
    }
}

// Fonction pour mettre à jour le niveau d'expansion
function updateExpansionLevel() {
    try {
        // Vérifier que la structure d'expansion est valide
        if (!game.expansion || !Array.isArray(game.expansion.milestones) || 
            !Array.isArray(game.expansion.levelNames)) {
            console.error("Structure d'expansion invalide");
            return;
        }
        
        // Compter les jalons débloqués
        const unlockedMilestones = game.expansion.milestones.filter(m => m && m.unlocked).length;
        
        // Chaque groupe de 3 jalons débloque un nouveau niveau d'expansion
        const newLevel = Math.floor(unlockedMilestones / 3);
        
        // Limiter le niveau au nombre de noms disponibles
        const safeNewLevel = Math.min(newLevel, game.expansion.levelNames.length - 1);
        
        if (safeNewLevel > game.expansion.currentLevel) {
            game.expansion.currentLevel = safeNewLevel;
            
            // Mettre à jour l'affichage si l'élément existe
            if (elements.expansionLevel) {
                const levelName = game.expansion.levelNames[safeNewLevel] || "Niveau maximum";
                elements.expansionLevel.textContent = levelName;
            }
            
            // Si le niveau est >= 2, déverrouiller le prestige
            if (safeNewLevel >= 2 && game.prestige && !game.prestige.unlocked) {
                game.prestige.unlocked = true;
                
                // Vérifier si l'élément existe avant de modifier son style
                const prestigeSection = document.getElementById('prestige-section');
                if (prestigeSection) {
                    prestigeSection.style.display = 'block';
                }
            }
            
            // Notification de niveau
            try {
                const levelName = game.expansion.levelNames[safeNewLevel] || "Niveau maximum";
                createNotification(`Expansion atteinte: ${levelName}`);
            } catch (notifError) {
                console.error("Erreur lors de la création de notification d'expansion:", notifError);
            }
        }
        
        // Calculer la progression vers le prochain niveau
        try {
            if (safeNewLevel < game.expansion.levelNames.length - 1) {
                // Valeurs par défaut sécurisées
                const totalNanobots = Number(game.totalNanobots) || 0;
                
                // Seuils pour le niveau actuel et le suivant
                const currentThreshold = Math.pow(10, 3 + (safeNewLevel * 3)); // 1e3, 1e6, 1e9, etc.
                const nextThreshold = Math.pow(10, 3 + ((safeNewLevel + 1) * 3));
                
                // Calcul de la progression logarithmique
                const progress = (Math.log10(Math.max(totalNanobots, 1)) - Math.log10(currentThreshold)) / 
                                (Math.log10(nextThreshold) - Math.log10(currentThreshold));
                
                // S'assurer que la progression est entre 0 et 1
                const clampedProgress = Math.min(Math.max(progress, 0), 1);
                
                // Vérifier que la valeur n'est pas NaN ou Infinity
                game.expansion.progressToNext = !isNaN(clampedProgress) && isFinite(clampedProgress) 
                    ? clampedProgress : 0;
                
                // Mettre à jour l'interface si les éléments existent
                if (elements.expansionProgress) {
                    elements.expansionProgress.style.width = `${game.expansion.progressToNext * 100}%`;
                }
                if (elements.expansionPercent) {
                    elements.expansionPercent.textContent = Math.floor(game.expansion.progressToNext * 100);
                }
            } else {
                // Niveau maximum atteint
                game.expansion.progressToNext = 1;
                
                if (elements.expansionProgress) {
                    elements.expansionProgress.style.width = '100%';
                }
                if (elements.expansionPercent) {
                    elements.expansionPercent.textContent = '100';
                }
            }
        } catch (progressError) {
            console.error("Erreur lors du calcul de la progression d'expansion:", progressError);
            
            // Valeurs par défaut en cas d'erreur
            game.expansion.progressToNext = 0;
            if (elements.expansionProgress) elements.expansionProgress.style.width = '0%';
            if (elements.expansionPercent) elements.expansionPercent.textContent = '0';
        }
    } catch (error) {
        console.error("Erreur critique lors de la mise à jour du niveau d'expansion:", error);
    }
}

// Fonction pour acheter un producteur
function buyProducer(index) {
    console.log(`Tentative d'achat du producteur ${index}`);
    
    // Vérifier que l'index est valide
    if (index < 0 || !Array.isArray(game.producers) || index >= game.producers.length) {
        console.error(`Index de producteur invalide: ${index}`);
        return;
    }
    
    const producer = game.producers[index];
    console.log(`Producteur sélectionné:`, producer.name, `(count: ${producer.count})`);
    
    try {
        // Obtenir le coût avec type forcé en nombre
        const cost = Number(getProducerCost(producer));
        console.log(`Coût calculé: ${cost}, Type: ${typeof cost}`);
        
        // Convertir explicitement game.nanobots en nombre
        const currentNanobots = Number(game.nanobots);
        console.log(`Nanobots actuels: ${currentNanobots}, Type: ${typeof currentNanobots}`);
        
        // Vérifier si le joueur peut acheter
        if (currentNanobots >= cost) {
            console.log(`Achat possible: ${currentNanobots} >= ${cost}`);
            
            // Mettre à jour les ressources et le compteur
            game.nanobots = currentNanobots - cost;
            producer.count++;
            
            console.log(`Achat réussi! Nouveau compte de ${producer.name}: ${producer.count}`);
            console.log(`Nanobots restants: ${game.nanobots}`);
            
            // Mettre à jour l'interface
            updateUI();
            
            // Effets visuels
            createFloatingNanobots(10);
            
            // Notification d'achat
            createNotification(`${producer.name} acheté!`, 'success');
        } else {
            console.log(`Achat impossible: ${currentNanobots} < ${cost}`);
            createNotification(`Pas assez de nanobots pour acheter ${producer.name}`, 'error');
        }
    } catch (error) {
        console.error(`Erreur lors de l'achat du producteur:`, error);
    }
}

// Fonction pour acheter une amélioration
function buyUpgrade(index) {
    // Vérifier que l'index est valide
    if (index < 0 || index >= game.upgrades.length) {
        console.error(`Index d'amélioration non valide: ${index}`);
        return;
    }
    
    const upgrade = game.upgrades[index];
    
    // Vérifier si l'amélioration a une condition et si elle est remplie
    if (upgrade.requirement) {
        try {
            const requirementMet = upgrade.requirement();
            if (!requirementMet) {
                return;
            }
        } catch (error) {
            console.error(`Erreur lors de l'évaluation de la condition pour ${upgrade.name}:`, error);
            return;
        }
    }
    
    if (game.nanobots >= upgrade.cost && !upgrade.purchased) {
        game.nanobots -= upgrade.cost;
        upgrade.purchased = true;
        
        try {
            upgrade.effect();
        } catch (error) {
            console.error(`Erreur lors de l'application de l'effet pour ${upgrade.name}:`, error);
            // On continue même en cas d'erreur pour éviter de bloquer le jeu
        }
        
        updateUI();
        
        // Effets visuels
        createFloatingNanobots(20);
        createNotification(`Amélioration achetée: ${upgrade.name}`, 'success');
    }
}

// Fonction pour effectuer un prestige
function performPrestige() {
    const pointsToGain = calculatePrestigeGain();
    
    if (pointsToGain < 1) return;
    
    game.prestige.points += pointsToGain;
    game.prestige.multiplier = 1 + (game.prestige.points * 0.1); // +10% par point
    game.stats.prestigeCount++;
    
    // Réinitialiser le jeu tout en conservant le prestige
    game.nanobots = 0;
    game.totalNanobots = 0;
    
    // Réinitialiser les producteurs
    game.producers.forEach(producer => {
        producer.count = 0;
        producer.unlocked = producer.id === 'producer1'; // Seul le premier est déverrouillé
    });
    
    // Réinitialiser les améliorations
    game.upgrades.forEach(upgrade => {
        upgrade.purchased = false;
    });
    
    // Réinitialiser les boosts temporaires et la singularité
    game.temporaryBoosts = [];
    game.singularityActive = false;
    
    // Conserver les jalons d'expansion débloqués
    game.expansion.progressToNext = 0;
    
    // Réinitialiser le clickValue
    game.clickValue = 1;
    
    // Mettre à jour l'interface
    updateUI();
    saveGame(false); // Sauvegarde manuelle après prestige
    
    // Effets visuels
    createFloatingNanobots(100, 'rgba(156, 39, 176, 0.7)');
}

// Fonction pour créer une notification de déblocage
/**
 * Crée une notification pour informer l'utilisateur
 * @param {string} message - Le message à afficher
 * @param {string} [type='info'] - Le type de notification ('info', 'success', etc.)
 */
function createNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    // Animation d'entrée
    setTimeout(() => {
        notification.classList.add('show');
    }, 10);
    
    // Suppression automatique (plus long pour les succès)
    const duration = type === 'success' ? 5000 : 3000;
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
            notification.remove();
        }, 500);
    }, duration);
}

/**
 * Vérifie si de nouveaux succès ont été débloqués
 * @returns {boolean} - True si au moins un succès a été débloqué
 */
function checkAchievements() {
    let achievementUnlocked = false;
    
    // Parcourir tous les succès non débloqués
    game.achievements.forEach(achievement => {
        // Vérifions d'abord si la condition existe et est une fonction
        if (!achievement.unlocked && typeof achievement.condition === 'function') {
            try {
                // Entourer l'appel de la condition d'un try-catch pour éviter les erreurs
                if (achievement.condition()) {
                    // Débloquer le succès
                    achievement.unlocked = true;
                    game.achievementBonus += 1; // +1% de production par succès
                    
                    // Notifier l'utilisateur avec une notification spéciale
                    createNotification(`🏆 Succès débloqué : ${achievement.name}`, 'success');
                    
                    achievementUnlocked = true;
                }
            } catch (error) {
                console.error(`Erreur lors de la vérification du succès ${achievement.id}:`, error);
            }
        }
    });
    
    return achievementUnlocked;
}

// Fonction pour créer des nanobots flottants
function createFloatingNanobots(count, color = 'rgba(0, 229, 255, 0.7)') {
    for (let i = 0; i < count; i++) {
        setTimeout(() => {
            const nanobot = document.createElement('div');
            nanobot.className = 'floating-nanobot';
            nanobot.style.backgroundColor = color;
            nanobot.style.boxShadow = `0 0 4px ${color}`;
            
            // Position aléatoire près du centre de l'écran
            const x = window.innerWidth / 2 + (Math.random() * 200 - 100);
            const y = window.innerHeight / 2 + (Math.random() * 200 - 100);
            
            nanobot.style.left = `${x}px`;
            nanobot.style.top = `${y}px`;
            
            // Direction aléatoire
            const randomDuration = 2 + Math.random() * 2;
            const randomDelay = Math.random() * 0.5;
            nanobot.style.animation = `float-up ${randomDuration}s ease-out ${randomDelay}s forwards`;
            
            document.body.appendChild(nanobot);
            
            // Supprimer après l'animation
            setTimeout(() => {
                nanobot.remove();
            }, (randomDuration + randomDelay) * 1000);
        }, Math.random() * 500);
    }
}

// Mettre à jour l'affichage des producteurs
function updateProducers() {
    console.log("Mise à jour des producteurs...");
    
    // Vérification que le conteneur existe
    if (!elements.producersContainer) {
        console.error("Conteneur des producteurs non trouvé!");
        return;
    }
    
    // Vider le conteneur des producteurs
    elements.producersContainer.innerHTML = '';
    
    // Vérification que game.producers est un tableau
    if (!Array.isArray(game.producers)) {
        console.error("game.producers n'est pas un tableau:", game.producers);
        return;
    }
    
    console.log("Nombre de producteurs:", game.producers.length);
    console.log("État actuel des nanobots:", game.nanobots, "Type:", typeof game.nanobots);
    
    // Convertir explicitement game.nanobots en nombre pour éviter les problèmes de comparaison
    const currentNanobots = Number(game.nanobots);
    console.log("Nanobots convertis:", currentNanobots, "Type après conversion:", typeof currentNanobots);
    
    // Parcourir tous les producteurs
    game.producers.forEach((producer, index) => {
        // Vérifier que le producteur est un objet valide
        if (!producer || typeof producer !== 'object') {
            console.error(`Producteur ${index} invalide:`, producer);
            return;
        }
        
        console.log(`Traitement du producteur ${index}:`, producer.name, "Déverrouillé:", producer.unlocked);
        
        // Vérifier si le producteur est déverrouillé
        if (!producer.unlocked) {
            console.log(`Producteur ${producer.name} non déverrouillé, vérification des conditions de déverrouillage`);
            
            const baseCost = Number(producer.baseCost) || 10;
            console.log(`Conditions de déverrouillage: nanobots >= ${baseCost * 0.5} OU totalNanobots >= ${baseCost}`);
            
            if (currentNanobots >= baseCost * 0.5 || Number(game.totalNanobots) >= baseCost) {
                console.log(`Conditions remplies, déverrouillage de ${producer.name}`);
                producer.unlocked = true;
            } else {
                console.log(`Conditions non remplies, ${producer.name} reste verrouillé`);
                return; // Passer au producteur suivant
            }
        }
        
        // Log avant calcul du coût
        console.log('Vérification producteur:', producer.name, 'Nanobots actuels:', currentNanobots, 'Type de currentNanobots:', typeof currentNanobots);
        
        // Obtenir le coût du producteur
        const cost = getProducerCost(producer);
        
        // Log après calcul du coût
        console.log('Coût calculé pour', producer.name, ':', cost, 'Type de cost:', typeof cost);
        
        // Vérifier si le joueur peut acheter le producteur (avec conversion explicite)
        const canBuy = currentNanobots >= Number(cost);
        
        // Log après vérification de la possibilité d'achat
        console.log('Peut acheter', producer.name, '?', canBuy, `(${currentNanobots} >= ${cost})`);
        
        // Créer l'élément HTML pour le producteur
        const producerElement = document.createElement('div');
        producerElement.className = 'producer-item';
        
        // Générer le contenu HTML
        producerElement.innerHTML = `
            <div class="producer-info">
                <div class="producer-title"><i class="fas fa-${producer.icon}"></i> ${producer.name} (${producer.count})</div>
                <div class="producer-stats">
                    Produit ${formatNumber(producer.production)} nanobots/sec<br>
                    Total: ${formatNumber(producer.count * producer.production)} nanobots/sec<br>
                    <small>${producer.desc}</small>
                </div>
            </div>
            <button class="buy-button" data-producer="${index}" ${canBuy ? '' : 'disabled'}>
                ${formatNumber(cost)} <i class="fas fa-microchip"></i>
            </button>
        `;
        
        // Ajouter l'élément au conteneur
        elements.producersContainer.appendChild(producerElement);
    });
    
    console.log("Ajout des écouteurs d'événements aux boutons d'achat");
    
    // Ajouter les écouteurs d'événements pour les boutons d'achat
    document.querySelectorAll('.buy-button[data-producer]').forEach(button => {
        button.addEventListener('click', function() {
            const producerIndex = parseInt(this.getAttribute('data-producer'));
            console.log(`Clic sur le bouton d'achat pour le producteur ${producerIndex}`);
            buyProducer(producerIndex);
        });
    });
}

// Mettre à jour l'affichage des améliorations
function updateUpgrades() {
    elements.upgradesContainer.innerHTML = '';
    
    // Mise à jour des améliorations
    game.upgrades.forEach((upgrade, index) => {
        // Si l'amélioration est déjà achetée, ne pas l'afficher
        if (upgrade.purchased) {
            return;
        }
        
        // Vérifier si l'amélioration a une condition de déverrouillage
        if (upgrade.requirement) {
            try {
                const requirementMet = upgrade.requirement();
                if (!requirementMet) return;
            } catch (error) {
                console.error(`Erreur lors de l'évaluation de la condition pour ${upgrade.name}:`, error);
                return;
            }
        }
        
        const canBuy = game.nanobots >= upgrade.cost;
        
        const upgradeElement = document.createElement('div');
        upgradeElement.className = 'upgrade-item';
        upgradeElement.innerHTML = `
            <div class="upgrade-info">
                <div class="upgrade-title"><i class="fas fa-${upgrade.icon}"></i> ${upgrade.name}</div>
                <div class="upgrade-desc">${upgrade.description}</div>
            </div>
            <button class="buy-button" data-upgrade="${index}" ${canBuy ? '' : 'disabled'}>
                ${formatNumber(upgrade.cost)} <i class="fas fa-microchip"></i>
            </button>
        `;
        
        elements.upgradesContainer.appendChild(upgradeElement);
    });
    
    // Ajouter les écouteurs d'événements pour les boutons d'achat
    document.querySelectorAll('.buy-button[data-upgrade]').forEach(button => {
        button.addEventListener('click', function() {
            const upgradeIndex = parseInt(this.getAttribute('data-upgrade'));
            buyUpgrade(upgradeIndex);
        });
    });
}

// Mettre à jour l'affichage des jalons
function updateMilestones() {
    elements.milestonesContainer.innerHTML = '';
    
    game.expansion.milestones.forEach((milestone, index) => {
        // N'afficher que les jalons débloqués et les prochains à débloquer
        if (!milestone.unlocked && game.totalNanobots < milestone.nanobotReq * 0.01 && index > 0) {
            // Ne pas afficher les jalons lointains
            return;
        }
        
        const milestoneElement = document.createElement('div');
        milestoneElement.className = 'milestone-item';
        
        if (milestone.unlocked) {
            milestoneElement.classList.add('unlocked');
        }
        
        // Identifier le prochain jalon à débloquer
        if (!milestone.unlocked && game.expansion.milestones[index-1]?.unlocked) {
            milestoneElement.classList.add('next');
        }
        
        milestoneElement.innerHTML = `
            <div class="milestone-icon"><i class="fas fa-${milestone.icon}"></i></div>
            <div class="milestone-name">${milestone.name}</div>
            <div class="milestone-desc">${milestone.desc}</div>
            ${!milestone.unlocked ? `<div class="milestone-req">${formatNumber(milestone.nanobotReq)} nanobots</div>` : ''}
        `;
        
        elements.milestonesContainer.appendChild(milestoneElement);
    });
}

// Mettre à jour l'affichage du prestige
function updatePrestige() {
    // Cacher la section si le prestige n'est pas encore débloqué
    document.getElementById('prestige-section').style.display = game.prestige.unlocked ? 'block' : 'none';
    
    if (!game.prestige.unlocked) return;
    
    const pointsToGain = calculatePrestigeGain();
    
    elements.prestigePoints.textContent = game.prestige.points;
    elements.prestigeMultiplier.textContent = `x${game.prestige.multiplier.toFixed(2)}`;
    elements.prestigeToGain.textContent = pointsToGain;
    
    // Activer le bouton de prestige seulement si on peut gagner au moins 1 point
    elements.prestigeButton.disabled = pointsToGain < 1;
}

// Fonction pour mettre à jour l'interface utilisateur
function updateUI() {
    try {
        console.log("Mise à jour de l'interface utilisateur");
        
        // Assurer que game existe et est un objet valide
        if (!game || typeof game !== 'object') {
            console.error("État du jeu invalide dans updateUI");
            return;
        }
        
        // Vérifier et convertir les valeurs principales en nombres
        game.nanobots = Number(game.nanobots) || 0;
        game.totalNanobots = Number(game.totalNanobots) || 0;
        game.clickValue = Number(game.clickValue) || 1;
        
        console.log("Valeurs principales après conversion:", 
            "nanobots:", game.nanobots, 
            "totalNanobots:", game.totalNanobots, 
            "clickValue:", game.clickValue);
        
        // Mise à jour des compteurs principaux
        if (elements.nanobots) {
            elements.nanobots.textContent = formatNumber(game.nanobots);
        }
        
        if (elements.perSecond) {
            elements.perSecond.textContent = formatNumber(calculateProduction());
        }
        
        if (elements.clickValue) {
            elements.clickValue.textContent = formatNumber(game.clickValue);
        }
        
        // Vérifier que l'expansion existe et est correctement initialisée
        if (game.expansion && Array.isArray(game.expansion.levelNames)) {
            // Vérifier et corriger currentLevel si nécessaire
            const maxLevel = game.expansion.levelNames.length - 1;
            game.expansion.currentLevel = Math.min(
                Math.max(0, Number(game.expansion.currentLevel) || 0),
                maxLevel
            );
            
            if (elements.expansionLevel) {
                elements.expansionLevel.textContent = game.expansion.levelNames[game.expansion.currentLevel];
            }
            
            // Vérifier et corriger progressToNext
            game.expansion.progressToNext = Math.min(
                Math.max(0, Number(game.expansion.progressToNext) || 0),
                1
            );
            
            if (elements.expansionProgress) {
                elements.expansionProgress.style.width = `${game.expansion.progressToNext * 100}%`;
            }
            
            if (elements.expansionPercent) {
                elements.expansionPercent.textContent = Math.floor(game.expansion.progressToNext * 100);
            }
        } else {
            console.error("Structure d'expansion invalide dans updateUI");
        }
        
        // Mise à jour des différentes sections de l'interface
        updateProducers();
        updateUpgrades();
        updateMilestones();
        updatePrestige();
        updateAchievements();
        
    } catch (error) {
        console.error("Erreur lors de la mise à jour de l'interface:", error);
    }
}

/**
 * Mettre à jour l'affichage des succès
 */
function updateAchievements() {
    // Mettre à jour le bonus d'achievements
    elements.achievementsBonus.textContent = game.achievementBonus;
    
    // Vider le conteneur
    elements.achievementsContainer.innerHTML = '';
    
    // Afficher chaque achievement
    game.achievements.forEach(achievement => {
        const achievementElement = document.createElement('div');
        achievementElement.className = `achievement-item ${achievement.unlocked ? 'unlocked' : 'locked'}`;
        
        achievementElement.innerHTML = `
            <div class="achievement-icon"><i class="fas fa-${achievement.icon}"></i></div>
            <div class="achievement-name">${achievement.name}</div>
            <div class="achievement-desc">${achievement.description}</div>
            <div class="achievement-reward">${achievement.rewardText}</div>
        `;
        
        elements.achievementsContainer.appendChild(achievementElement);
    });
}

// Sauvegarder le jeu
/**
 * Affiche une notification discrète pour la sauvegarde automatique
 * @param {boolean} isAuto - Indique si la sauvegarde est automatique
 */
function showSaveNotification(isAuto = false) {
    // Supprime toute notification précédente
    const existingNotification = document.querySelector('.autosave-notification');
    if (existingNotification) {
        existingNotification.remove();
    }
    
    // Crée la notification
    const notification = document.createElement('div');
    notification.className = 'autosave-notification';
    notification.textContent = isAuto ? '💾 Sauvegarde auto...' : '💾 Jeu sauvegardé!';
    
    document.body.appendChild(notification);
    
    // Animation d'entrée
    setTimeout(() => {
        notification.classList.add('show');
    }, 10);
    
    // Suppression automatique
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => {
            notification.remove();
        }, 300);
    }, 2000);
}

/**
 * Sauvegarde l'état du jeu dans le localStorage
 * @param {boolean} isAuto - Indique si la sauvegarde est automatique
 */
function saveGame(isAuto = false) {
    try {
        // Sanitize game state before saving to avoid corrupted saves
        sanitizeGameState(game);
        
        // Make a clean copy to avoid circular references
        const gameToSave = JSON.parse(JSON.stringify(game));
        
        // Remove properties we don't need to save
        delete gameToSave.gameLoopId;
        delete gameToSave.offlineGainNotification;
        
        const saveData = JSON.stringify(gameToSave);
        localStorage.setItem('nanoBotExperienceSave', saveData);
        
        // Update last save timestamp
        game.lastSave = Date.now();
        
        // Update UI if lastSave element exists
        if (elements.lastSave) {
            elements.lastSave.textContent = formatTime(game.lastSave);
        }
        
        // Show notification if appropriate
        if (!isAuto || (game.settings && game.settings.showAutoSaveNotification !== false)) {
            showSaveNotification(isAuto);
        }
        
        console.log("Jeu sauvegardé avec succès à", new Date(game.lastSave).toLocaleString());
        return true;
    } catch (error) {
        console.error("Erreur lors de la sauvegarde du jeu:", error);
        createNotification("Erreur lors de la sauvegarde du jeu!", "error");
        return false;
    }
}

// Charger le jeu
/**
 * Tente de charger la sauvegarde du jeu.
 * Si aucune sauvegarde n'est trouvée ou si elle est corrompue, initialise une nouvelle partie.
 * @returns {boolean} - true si une sauvegarde a été chargée avec succès, false sinon
 */
function loadGame() {
    const saveKey = 'nanoBotExperienceSave';
    console.log("Tentative de chargement de la sauvegarde...");
    let hasSave = false;
    
    try {
        const saveData = localStorage.getItem(saveKey);
        
        // Si aucune sauvegarde n'est trouvée, initialiser avec l'état par défaut
        if (!saveData) {
            console.log("Aucune sauvegarde trouvée, initialisation d'un nouveau jeu");
            const defaultState = getDefaultGameState();
            if (!defaultState) {
                throw new Error("Échec de la récupération de l'état par défaut");
            }
            game = defaultState;
            game.hasSaveLoaded = false;
            return false;
        }
        
        hasSave = true;
        console.log("Sauvegarde trouvée, tentative de parse JSON");
        
        // Tenter de parser la sauvegarde
        let loadedState;
        try {
            loadedState = JSON.parse(saveData);
        } catch (parseError) {
            console.error("Erreur lors du parsing JSON de la sauvegarde:", parseError);
            // Sauvegarde corrompue, la supprimer
            localStorage.removeItem(saveKey);
            createNotification("Sauvegarde corrompue détectée et supprimée. Démarrage d'une nouvelle partie.", "error");
            const defaultState = getDefaultGameState();
            if (!defaultState) {
                throw new Error("Échec de la récupération de l'état par défaut");
            }
            game = defaultState;
            game.hasSaveLoaded = false;
            return false;
        }
        
        // S'assurer que loadedState est bien un objet
        if (!loadedState || typeof loadedState !== 'object') {
            console.error("La sauvegarde n'est pas un objet valide");
            localStorage.removeItem(saveKey);
            const defaultState = getDefaultGameState();
            if (!defaultState) {
                throw new Error("Échec de la récupération de l'état par défaut");
            }
            game = defaultState;
            game.hasSaveLoaded = false;
            return false;
        }
        
        // Obtenir un état par défaut pour la fusion
        const defaultState = getDefaultGameState();
        if (!defaultState) {
            throw new Error("Échec de la récupération de l'état par défaut");
        }
        
        // Fusionner et nettoyer l'état chargé avec notre fonction sanitize améliorée
        console.log("Fusion et sanitization de l'état du jeu chargé");
        const cleanState = sanitizeGameState(loadedState, defaultState);
        
        // Réinitialiser gameLoopId pour éviter les doublons de boucle de jeu
        cleanState.gameLoopId = null;
        cleanState.hasSaveLoaded = true;
        
        // Assigner le nouvel état propre à game
        game = cleanState;
        
        // Calcul des gains hors ligne
        const currentTime = Date.now();
        const lastUpdate = Number(game.lastUpdate) || currentTime;
        const offlineTime = Math.max(0, (currentTime - lastUpdate) / 1000); // en secondes
        
        if (offlineTime > 10) { // Si plus de 10 secondes se sont écoulées
            try {
                const production = calculateProduction();
                const offlineGain = production * offlineTime;
                
                if (!isNaN(offlineGain) && isFinite(offlineGain) && offlineGain > 0) {
                    game.nanobots += offlineGain;
                    game.totalNanobots += offlineGain;
                    
                    // Vérification des nouveaux jalons
                    checkMilestones();
                    
                    // Stocker le message pour l'afficher plus tard
                    game.offlineGainNotification = `Vous avez gagné ${formatNumber(offlineGain)} nanobots pendant votre absence!`;
                }
            } catch (offlineError) {
                console.error("Erreur lors du calcul des gains hors ligne:", offlineError);
            }
        }
        
        // Mise à jour du temps
        game.lastUpdate = currentTime;
        
        console.log('Jeu chargé avec succès!');
        return true; // Indique qu'une sauvegarde a été chargée avec succès
    } catch (error) {
        console.error('Erreur critique lors du chargement de la sauvegarde:', error);
        
        // En cas d'erreur grave, supprimer la sauvegarde corrompue
        if (hasSave) {
            localStorage.removeItem(saveKey);
            createNotification("Erreur lors du chargement de la sauvegarde. La sauvegarde a été supprimée.", "error");
        }
        
        // Initialiser avec un état par défaut propre
        const defaultState = getDefaultGameState();
        if (!defaultState) {
            console.error("État par défaut non disponible après erreur critique");
            // Dernier recours: créer un état minimal
            game = {
                nanobots: 0,
                totalNanobots: 0,
                clickValue: 1,
                lastUpdate: Date.now(),
                producers: [],
                upgrades: [],
                hasSaveLoaded: false
            };
        } else {
            game = defaultState;
            game.hasSaveLoaded = false;
        }
        
        return false;
    }
}

// Réinitialiser le jeu
function resetGame() {
    if (confirm('Êtes-vous sûr de vouloir réinitialiser tout le jeu? Vous perdrez toute votre progression, y compris les points d\'évolution!')) {
        // Arrêter la boucle de jeu actuelle
        stopGameLoop();
        
        // Supprimer la sauvegarde du localStorage
        localStorage.removeItem('nanoBotExperienceSave');
        
        // Démarrer une nouvelle partie
        startNewGame();
    }
}

// Boucle principale du jeu
function gameLoop() {
    try {
        // Validation de la structure de base du jeu
        if (!game || typeof game !== 'object') {
            console.error("Structure de jeu invalide dans gameLoop");
            return;
        }
        
        // Obtenir le timestamp actuel et calculer le delta temps
        const currentTime = Date.now();
        const lastUpdate = Number(game.lastUpdate) || currentTime;
        
        // Limiter deltaTime à 60 secondes max pour éviter les grands sauts en cas de mise en pause prolongée
        const deltaTime = Math.min((currentTime - lastUpdate) / 1000, 60);
        
        // Calculer la production actuelle (avec protection contre NaN)
        let production = 0;
        try {
            production = calculateProduction();
        } catch (prodError) {
            console.error("Erreur lors du calcul de la production:", prodError);
        }
        
        // Mise à jour des ressources avec protection contre NaN et valeurs négatives
        if (!isNaN(production) && isFinite(production) && production >= 0) {
            // Incrémenter les nanobots avec protection contre NaN
            const nanobotsGain = production * deltaTime;
            if (!isNaN(nanobotsGain) && isFinite(nanobotsGain)) {
                game.nanobots = Number(game.nanobots) || 0;
                game.nanobots += nanobotsGain;
                
                game.totalNanobots = Number(game.totalNanobots) || 0;
                game.totalNanobots += nanobotsGain;
            }
        }
        
        // Assurer que les valeurs ne deviennent jamais NaN
        if (isNaN(game.nanobots) || !isFinite(game.nanobots)) {
            console.error("Valeur de nanobots invalide détectée:", game.nanobots);
            game.nanobots = 0;
        }
        
        if (isNaN(game.totalNanobots) || !isFinite(game.totalNanobots)) {
            console.error("Valeur de totalNanobots invalide détectée:", game.totalNanobots);
            game.totalNanobots = 0;
        }
        
        // Appliquer la singularité si active (consomme 1% des nanobots par seconde)
        if (game.singularityActive) {
            try {
                const consumption = game.nanobots * 0.01 * deltaTime;
                if (!isNaN(consumption) && isFinite(consumption)) {
                    game.nanobots = Math.max(0, game.nanobots - consumption);
                }
            } catch (singularityError) {
                console.error("Erreur lors de l'application de la singularité:", singularityError);
            }
        }
        
        // Nettoyer les boosts temporaires expirés
        try {
            if (Array.isArray(game.temporaryBoosts)) {
                game.temporaryBoosts = game.temporaryBoosts.filter(boost => 
                    boost && typeof boost === 'object' && Number(boost.expiryTime) > currentTime);
            } else {
                game.temporaryBoosts = [];
            }
        } catch (boostError) {
            console.error("Erreur lors du nettoyage des boosts temporaires:", boostError);
            game.temporaryBoosts = [];
        }
        
        // Initialiser les flags de mise à jour
        let achievementsUpdated = false;
        let milestonesUpdated = false;
        let needUIUpdate = false;
        
        // Vérifier et débloquer des succès
        try {
            achievementsUpdated = checkAchievements();
        } catch (achievementError) {
            console.error("Erreur lors de la vérification des succès:", achievementError);
        }
        
        // Vérifier et débloquer des jalons
        try {
            milestonesUpdated = checkMilestones();
        } catch (milestoneError) {
            console.error("Erreur lors de la vérification des jalons:", milestoneError);
        }
        
        // Mettre à jour l'interface si nécessaire
        if (milestonesUpdated || achievementsUpdated) {
            try {
                updateUI();
            } catch (uiError) {
                console.error("Erreur lors de la mise à jour de l'interface:", uiError);
            }
        } else {
            // Mise à jour minimale des affichages qui changent constamment
            try {
                if (elements.nanobots) {
                    elements.nanobots.textContent = formatNumber(game.nanobots);
                }
                if (elements.perSecond) {
                    elements.perSecond.textContent = formatNumber(production);
                }
                
                // Vérification des déverrouillages (producteurs et améliorations)
                if (Array.isArray(game.producers)) {
                    game.producers.forEach(producer => {
                        if (producer && typeof producer === 'object' && 
                            !producer.unlocked && 
                            ((game.nanobots >= producer.baseCost * 0.5) || 
                             (game.totalNanobots >= producer.baseCost))) {
                            producer.unlocked = true;
                            needUIUpdate = true;
                        }
                    });
                }
                
                // Mise à jour des points de prestige à gagner
                if (game.prestige) {
                    try {
                        const newPrestigeToGain = calculatePrestigeGain();
                        if (game.prestige.toGain !== newPrestigeToGain) {
                            game.prestige.toGain = newPrestigeToGain;
                            
                            if (elements.prestigeToGain) {
                                elements.prestigeToGain.textContent = newPrestigeToGain;
                            }
                            if (elements.prestigeButton) {
                                elements.prestigeButton.disabled = newPrestigeToGain < 1;
                            }
                        }
                    } catch (prestigeError) {
                        console.error("Erreur lors du calcul des points de prestige:", prestigeError);
                    }
                }
                
                // Mise à jour complète de l'interface si nécessaire
                if (needUIUpdate) {
                    try {
                        updateUI();
                    } catch (uiUpdateError) {
                        console.error("Erreur lors de la mise à jour complète de l'interface:", uiUpdateError);
                    }
                }
            } catch (minUpdateError) {
                console.error("Erreur lors de la mise à jour minimale:", minUpdateError);
            }
        }
        
        // Sauvegarde automatique toutes les 30 secondes
        try {
            const lastSave = Number(game.lastSave) || 0;
            if (currentTime - lastSave > 30000) { // 30000 ms = 30 secondes
                saveGame(true); // Passe 'true' pour indiquer que c'est une sauvegarde automatique
            }
        } catch (saveError) {
            console.error("Erreur lors de la sauvegarde automatique:", saveError);
        }
        
        // Mise à jour du temps
        game.lastUpdate = currentTime;
        
        // Mise à jour du temps de jeu
        if (game.stats) {
            game.stats.playTime = Number(game.stats.playTime) || 0;
            game.stats.playTime += deltaTime;
        }
        
        // Continuer la boucle de jeu avec requestAnimationFrame
        game.gameLoopId = requestAnimationFrame(gameLoop);
        
    } catch (criticalError) {
        console.error("Erreur critique dans la boucle de jeu:", criticalError);
        
        // Continuer la boucle malgré l'erreur pour éviter que le jeu ne se fige
        game.gameLoopId = requestAnimationFrame(gameLoop);
    }
}

// Initialisation
// Fonctions pour le changement de thème
function applyTheme(theme) {
    try {
        // Vérifier que le thème est valide, sinon utiliser le thème sombre par défaut
        if (theme !== 'light' && theme !== 'dark') {
            console.warn(`Thème invalide: ${theme}, utilisation du thème sombre par défaut`);
            theme = 'dark';
        }
        
        // Appliquer la classe CSS appropriée
        if (theme === 'light') {
            document.documentElement.classList.add('light-theme');
        } else {
            document.documentElement.classList.remove('light-theme');
        }
        
        // Mettre à jour l'icône du bouton de changement de thème
        if (elements.themeToggle) {
            try {
                const iconElement = elements.themeToggle.querySelector('i');
                if (iconElement) {
                    iconElement.className = theme === 'light' ? 'fas fa-sun' : 'fas fa-moon';
                }
            } catch (iconError) {
                console.error("Erreur lors de la mise à jour de l'icône de thème:", iconError);
            }
        }
        
        // S'assurer que game.settings existe
        if (!game.settings) {
            game.settings = {};
        }
        
        // Mettre à jour le paramètre de thème
        game.settings.theme = theme;
        
        return true;
    } catch (error) {
        console.error("Erreur lors de l'application du thème:", error);
        return false;
    }
}

function toggleTheme() {
    try {
        // S'assurer que game.settings existe
        if (!game.settings) {
            game.settings = { theme: 'dark' };
        }
        
        // Déterminer le nouveau thème
        const currentTheme = game.settings.theme || 'dark';
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        
        // Appliquer le nouveau thème
        if (applyTheme(newTheme)) {
            createNotification(`Thème ${newTheme === 'light' ? 'clair' : 'sombre'} activé`, 'info');
        }
        
        // Sauvegarder les préférences
        try {
            saveGame(true); // Sauvegarde silencieuse après changement de thème
        } catch (saveError) {
            console.error("Erreur lors de la sauvegarde des préférences de thème:", saveError);
        }
    } catch (error) {
        console.error("Erreur lors du changement de thème:", error);
    }
}

// Fonction pour configurer les boutons et fonctionnalités
function setupGameControls() {
    // Écouteurs d'événements pour les contrôles de jeu
    if (elements.clicker) {
        elements.clicker.addEventListener('click', () => {
            // Ajouter la valeur du clic
            game.nanobots += game.clickValue * game.prestige.multiplier;
            game.totalNanobots += game.clickValue * game.prestige.multiplier;
            game.stats.clickCount++;
            
            // Effet d'animation
            elements.nanobots.classList.add('nanobot-gain');
            setTimeout(() => {
                elements.nanobots.classList.remove('nanobot-gain');
            }, 500);
            
            // Créer des nanobots flottants
            createFloatingNanobots(3);
            
            // Mise à jour immédiate
            elements.nanobots.textContent = formatNumber(game.nanobots);
            
            // Vérifier les jalons et les succès
            const achievementsUpdated = checkAchievements();
            const milestonesUpdated = checkMilestones();
            
            if (milestonesUpdated || achievementsUpdated) {
                updateUI();
            }
        });
    }
    
    if (elements.saveButton) elements.saveButton.addEventListener('click', () => saveGame(false));
    if (elements.resetButton) elements.resetButton.addEventListener('click', resetGame);
    if (elements.prestigeButton) elements.prestigeButton.addEventListener('click', performPrestige);
    if (elements.themeToggle) elements.themeToggle.addEventListener('click', toggleTheme);
}

// Fonction pour afficher les options de démarrage
function showStartOptions() {
    const loadingScreen = document.getElementById('loading-screen');
    const loadingText = document.getElementById('loading-text');
    const startOptions = document.getElementById('start-options');
    const continueButton = document.getElementById('continue-button');
    const newGameButton = document.getElementById('new-game-button');
    
    // Masquer le spinner
    document.querySelector('.spinner').style.display = 'none';
    
    // Mettre à jour le texte de chargement
    loadingText.textContent = 'Nano Bot Experience';
    
    // Vérifier si une sauvegarde existe
    const hasSave = localStorage.getItem('nanoBotExperienceSave') !== null;
    
    // Afficher ou masquer le bouton continuer selon l'existence d'une sauvegarde
    if (hasSave) {
        continueButton.style.display = 'block';
        // Ajouter la classe d'avertissement au bouton nouvelle partie
        newGameButton.classList.add('warning');
    } else {
        continueButton.style.display = 'none';
        // Enlever la classe d'avertissement car il n'y a pas de sauvegarde à écraser
        newGameButton.classList.remove('warning');
    }
    
    // Afficher les options de démarrage
    startOptions.style.display = 'flex';
    
    // Ajouter une transition pour l'apparition progressive
    setTimeout(() => {
        startOptions.classList.add('show');
    }, 100);
    
    // Ajouter les écouteurs d'événements aux boutons
    continueButton.addEventListener('click', proceedToGame);
    
    newGameButton.addEventListener('click', () => {
        if (hasSave) {
            // Demander confirmation si une sauvegarde existe
            if (confirm('Êtes-vous sûr de vouloir commencer une nouvelle partie ? Votre progression actuelle sera perdue.')) {
                startNewGame();
            }
        } else {
            startNewGame();
        }
    });
}

// Fonction pour démarrer une nouvelle partie
/**
 * Démarre une nouvelle partie.
 * Réinitialise complètement l'état du jeu et démarre une nouvelle partie.
 */
function startNewGame() {
    console.log("Démarrage d'une nouvelle partie...");
    
    try {
        // S'assurer que la boucle de jeu précédente est arrêtée
        stopGameLoop();
        
        // Supprimer l'ancienne sauvegarde si elle existe
        localStorage.removeItem('nanoBotExperienceSave');
        
        // Obtenir un nouvel état de jeu par défaut
        const defaultState = getDefaultGameState();
        
        // Vérifier que l'état par défaut est valide
        if (!defaultState || typeof defaultState !== 'object') {
            throw new Error("État par défaut invalide obtenu");
        }
        
        // Assigner le nouvel état au jeu
        game = defaultState;
        game.hasSaveLoaded = false;
        
        console.log("Nouveau jeu initialisé avec état par défaut");
        
        // Sauvegarder immédiatement le nouvel état
        try {
            saveGame(true);
        } catch (saveError) {
            console.error("Erreur lors de la sauvegarde initiale:", saveError);
            // Continue même en cas d'erreur de sauvegarde
        }
        
        // Continuer vers le jeu
        proceedToGame();
        
        // Afficher un message de bienvenue
        setTimeout(() => {
            createNotification('Bienvenue dans Nano Bot Experience!', 'success');
        }, 1000);
    } catch (error) {
        console.error("Erreur critique lors du démarrage d'une nouvelle partie:", error);
        
        // En cas d'erreur grave, créer un état minimal
        game = {
            nanobots: 0,
            totalNanobots: 0,
            clickValue: 1,
            lastUpdate: Date.now(),
            producers: [],
            upgrades: [],
            hasSaveLoaded: false
        };
        
        // Tenter de continuer malgré tout
        proceedToGame();
        
        createNotification("Une erreur est survenue lors du démarrage. Le jeu pourrait ne pas fonctionner correctement.", "error");
    }
}

// Fonction pour continuer vers le jeu (après nouvelle partie ou chargement)
/**
 * Continue vers l'écran de jeu principal après le chargement ou la création d'une partie.
 * Configure l'interface et démarre la boucle de jeu.
 */
function proceedToGame() {
    console.log("Passage au jeu principal...");
    
    try {
        // Vérifier que l'état du jeu est valide
        if (!game || typeof game !== 'object') {
            throw new Error("État du jeu invalide");
        }
        
        // Vérifier que les structures essentielles existent
        if (!game.producers || !game.upgrades || !game.prestige || !game.expansion) {
            console.error("Structures essentielles manquantes dans l'état du jeu");
            
            // Tentative de récupération: obtenir un état par défaut
            const defaultState = getDefaultGameState();
            if (defaultState) {
                // Sauvegarder les ressources actuelles si elles existent
                const nanobots = typeof game.nanobots === 'number' ? game.nanobots : 0;
                const totalNanobots = typeof game.totalNanobots === 'number' ? game.totalNanobots : 0;
                
                // Réinitialiser le jeu avec l'état par défaut
                game = defaultState;
                
                // Restaurer les ressources
                game.nanobots = nanobots;
                game.totalNanobots = totalNanobots;
                
                console.log("État du jeu récupéré avec l'état par défaut");
            } else {
                throw new Error("Impossible de récupérer l'état du jeu");
            }
        }
        
        const loadingScreen = document.getElementById('loading-screen');
        const gameContainer = document.querySelector('.game-container');
        
        if (!loadingScreen || !gameContainer) {
            console.error("Éléments d'interface introuvables");
        }
        
        // S'assurer que la boucle de jeu précédente est arrêtée
        stopGameLoop();
        
        try {
            // Cacher la section de prestige jusqu'au déverrouillage
            const prestigeSection = document.getElementById('prestige-section');
            if (prestigeSection) {
                prestigeSection.style.display = game.prestige && game.prestige.unlocked ? 'block' : 'none';
            }
            
            // S'assurer que le thème est correctement appliqué
            if (game.settings && typeof game.settings.theme === 'string') {
                applyTheme(game.settings.theme);
            } else {
                applyTheme('dark'); // Thème par défaut
            }
            
            // Mettre à jour l'interface avec l'état actuel du jeu
            updateUI();
            
            // Configurer les contrôles du jeu
            setupGameControls();
        } catch (uiError) {
            console.error("Erreur lors de la configuration de l'interface:", uiError);
            // Continue malgré les erreurs d'interface
        }
        
        // Démarrer la boucle de jeu (s'assurer qu'elle n'est pas déjà en cours)
        console.log("Démarrage de la boucle de jeu");
        if (!game.gameLoopId) {
            game.gameLoopId = requestAnimationFrame(gameLoop);
        }
        
        // Transition vers le jeu
        if (loadingScreen) {
            loadingScreen.classList.add('hidden');
        }
        
        // Afficher le conteneur du jeu après un court délai pour la transition
        setTimeout(() => {
            if (gameContainer) {
                gameContainer.style.display = 'flex';
            }
            
            // Afficher le message de gain hors ligne s'il existe
            if (game.offlineGainNotification) {
                createNotification(game.offlineGainNotification);
                delete game.offlineGainNotification;
            }
        }, 500);
    } catch (error) {
        console.error("Erreur critique lors du passage au jeu principal:", error);
        
        // Tentative de récupération d'urgence
        try {
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
                loadingScreen.classList.add('hidden');
            }
            
            const gameContainer = document.querySelector('.game-container');
            if (gameContainer) {
                gameContainer.style.display = 'flex';
            }
            
            // Créer un état minimal et redémarrer
            game = getDefaultGameState() || {
                nanobots: 0,
                totalNanobots: 0,
                clickValue: 1,
                producers: [],
                upgrades: [],
                prestige: { unlocked: false, points: 0, multiplier: 1 },
                expansion: { currentLevel: 0, progressToNext: 0 },
                lastUpdate: Date.now()
            };
            
            // Forcer l'interface à se mettre à jour
            updateUI();
            
            // Démarrer une boucle de jeu d'urgence
            game.gameLoopId = requestAnimationFrame(gameLoop);
            
            createNotification("Une erreur critique est survenue. Le jeu a été réinitialisé.", "error");
        } catch (recoveryError) {
            console.error("Échec de la récupération d'urgence:", recoveryError);
            alert("Erreur critique. Veuillez recharger la page.");
        }
    }
}

// Fonction d'initialisation principale
/**
 * Fonction d'initialisation principale du jeu.
 * Appelée au chargement de la page.
 */
function init() {
    console.log('Initialisation de Nano Bot Experience v8...');
    
    // Initialisation des éléments
    try {
        // Initialiser game comme un objet vide pour éviter les erreurs de référence
        if (typeof game === 'undefined') {
            window.game = {};
        }
        
        // S'assurer qu'il n'y a pas de boucle de jeu active
        if (game.gameLoopId) {
            stopGameLoop();
        }
        
        // S'assurer que le conteneur du jeu est caché au départ
        const gameContainer = document.querySelector('.game-container');
        if (gameContainer) {
            gameContainer.style.display = 'none';
        }
        
        // Tester si getDefaultGameState fonctionne correctement
        const testDefaultState = getDefaultGameState();
        if (!testDefaultState || typeof testDefaultState !== 'object') {
            throw new Error("La fonction getDefaultGameState ne retourne pas un objet valide");
        }
        
        // Vérifier que les structures essentielles sont présentes
        if (!Array.isArray(testDefaultState.producers) || 
            !Array.isArray(testDefaultState.upgrades) || 
            !testDefaultState.expansion || 
            !testDefaultState.prestige) {
            throw new Error("L'état par défaut ne contient pas toutes les structures nécessaires");
        }
        
        // Charger la sauvegarde ou initialiser une nouvelle partie
        try {
            const saveLoaded = loadGame();
            console.log("État du chargement de la sauvegarde:", saveLoaded ? "Succès" : "Nouvelle partie");
            
            // Vérifier encore une fois que le jeu est dans un état valide
            if (!game || typeof game !== 'object') {
                throw new Error("État du jeu invalide après loadGame");
            }
            
            // Initialiser la dernière mise à jour si elle n'existe pas
            if (!game.lastUpdate) {
                game.lastUpdate = Date.now();
            }
        } catch (loadError) {
            console.error("Erreur lors du chargement du jeu:", loadError);
            
            // Récupération d'urgence
            localStorage.removeItem('nanoBotExperienceSave');
            game = getDefaultGameState();
            
            if (!game || typeof game !== 'object') {
                throw new Error("Impossible d'obtenir un état par défaut valide");
            }
            
            console.log("Récupération avec un nouvel état par défaut après erreur de chargement");
        }
        
        // S'assurer que les références aux éléments du DOM sont initialisées
        initializeElements();
        
        // Appliquer le thème du jeu une fois les éléments initialisés
        if (game.settings && game.settings.theme) {
            applyTheme(game.settings.theme);
        } else {
            applyTheme('dark'); // Thème par défaut
        }
        
        // Simuler un temps de chargement avant d'afficher les options de démarrage
        setTimeout(() => {
            showStartOptions();
        }, 1500);
    } catch (error) {
        console.error("Erreur critique lors de l'initialisation:", error);
        
        // En cas d'erreur grave, on réinitialise complètement
        try {
            localStorage.removeItem('nanoBotExperienceSave');
            
            // Créer un état minimal garanti
            window.game = {
                nanobots: 0,
                totalNanobots: 0,
                clickValue: 1,
                lastUpdate: Date.now(),
                producers: [],
                upgrades: [],
                prestige: { unlocked: false, points: 0, multiplier: 1 },
                expansion: { currentLevel: 0, progressToNext: 0 },
                settings: { theme: 'dark' }
            };
            
            // Afficher un message d'erreur
            alert("Une erreur critique est survenue. Le jeu a été réinitialisé. Rechargez la page si les problèmes persistent.");
            
            // Tenter d'afficher les options de démarrage malgré tout
            setTimeout(() => {
                try {
                    showStartOptions();
                } catch (startError) {
                    console.error("Impossible d'afficher les options de démarrage:", startError);
                    alert("Erreur critique. Veuillez recharger la page.");
                }
            }, 1000);
        } catch (recoveryError) {
            console.error("Échec de la récupération d'urgence:", recoveryError);
            alert("Erreur critique. Veuillez recharger la page.");
        }
    }
}

/**
 * Initialise les références aux éléments DOM utilisés dans le jeu.
 * Cette fonction garantit que les éléments de l'interface sont correctement liés.
 */
function initializeElements() {
    try {
        // Recharger tous les éléments du DOM
        window.elements = {
            nanobots: document.getElementById('nanobots') || document.createElement('div'),
            perSecond: document.getElementById('per-second') || document.createElement('div'),
            clickValue: document.getElementById('click-value') || document.createElement('div'),
            expansionLevel: document.getElementById('expansion-level') || document.createElement('div'),
            expansionProgress: document.getElementById('expansion-progress') || document.createElement('div'),
            expansionPercent: document.getElementById('expansion-percent') || document.createElement('div'),
            clicker: document.getElementById('clicker') || document.createElement('div'),
            producersContainer: document.getElementById('producers-container') || document.createElement('div'),
            upgradesContainer: document.getElementById('upgrades-container') || document.createElement('div'),
            milestonesContainer: document.getElementById('milestones-container') || document.createElement('div'),
            prestigePoints: document.getElementById('prestige-points') || document.createElement('div'),
            prestigeMultiplier: document.getElementById('prestige-multiplier') || document.createElement('div'),
            prestigeToGain: document.getElementById('prestige-to-gain') || document.createElement('div'),
            prestigeButton: document.getElementById('prestige-button') || document.createElement('button'),
            saveButton: document.getElementById('save-button') || document.createElement('button'),
            resetButton: document.getElementById('reset-button') || document.createElement('button'),
            themeToggle: document.getElementById('theme-toggle') || document.createElement('button'),
            lastSave: document.getElementById('last-save') || document.createElement('div'),
            achievementsContainer: document.getElementById('achievements-container') || document.createElement('div'),
            achievementsBonus: document.getElementById('achievements-bonus') || document.createElement('div')
        };
        
        console.log("Éléments DOM initialisés avec succès");
    } catch (error) {
        console.error("Erreur lors de l'initialisation des éléments DOM:", error);
    }
}

// Démarrer le jeu
document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
